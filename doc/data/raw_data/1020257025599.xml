<?xml version="1.0" encoding="UTF-8" standalone="yes"?><response><header><requestMsgID></requestMsgID><responseTime>2025-11-17 18:03:00.30</responseTime><responseMsgID></responseMsgID><successYN>Y</successYN><resultCode>00</resultCode><resultMsg>NORMAL SERVICE.</resultMsg></header><body><item><biblioSummaryInfoArray><biblioSummaryInfo><applicationDate>2023.01.03</applicationDate><applicationFlag> </applicationFlag><applicationNumber>10-2025-7025599</applicationNumber><claimCount>26</claimCount><examinerName> </examinerName><finalDisposal> </finalDisposal><inventionTitle>디코딩 방법, 인코딩 방법, 디코더 및 인코더</inventionTitle><inventionTitleEng>DECODING METHOD, CODING METHOD, DECODERS, AND CODERS</inventionTitleEng><openDate>2025.09.04</openDate><openNumber>10-2025-0132528</openNumber><originalApplicationDate> </originalApplicationDate><originalApplicationKind>국제출원/신규</originalApplicationKind><originalApplicationNumber> </originalApplicationNumber><originalExaminationRequestDate> </originalExaminationRequestDate><originalExaminationRequestFlag>N</originalExaminationRequestFlag><publicationDate> </publicationDate><publicationNumber> </publicationNumber><registerDate> </registerDate><registerNumber> </registerNumber><registerStatus>공개</registerStatus><translationSubmitDate>2025.07.30</translationSubmitDate></biblioSummaryInfo></biblioSummaryInfoArray><ipcInfoArray><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/105</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/593</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/176</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/70</ipcNumber></ipcInfo></ipcInfoArray><familyInfoArray><familyInfo/></familyInfoArray><abstractInfoArray><abstractInfo><astrtCont> 본 출원의 실시예는 디코딩 방법, 인코딩 방법, 디코더 및 인코더를 제공한다. 당해 디코딩 방법은, 비트스트림을 기반으로 현재 시퀀스 중 현재 블록의 잔차 블록을 결정하는 단계, 인트라 템플릿 매칭 예측(IntraTMP) 모드를 기반으로 당해 현재 블록의 적어도 하나의 매칭 블록을 예측하는 단계, 당해 적어도 하나의 매칭 블록을 기반으로 당해 현재 블록의 목표 예측 블록을 결정하는 단계, 및 당해 현재 블록의 잔차 블록과 당해 목표 예측 블록을 기반으로 당해 현재 블록의 재구성 블록을 얻는 단계를 포함한다. 본 출원의 실시예에서, 디코더는 당해 IntraTMP 모드로 선택된 단일 매칭 블록을 기반으로 당해 목표 예측 블록을 결정할 수도 있고, 당해 IntraTMP 모드로 선택된 복수 매칭 블록을 기반으로 당해 목표 예측 블록을 결정할 수도 있다. 이는 현재 블록의 예측 유연성을 향상시킬 뿐만 아니라, 디코더가 적절한 수의 매칭 블록을 선택하여 당해 목표 예측 블록을 결정하는 데도 유리하여, 코덱 성능을 향상시킬 수 있다. </astrtCont></abstractInfo></abstractInfoArray><internationalInfoArray><internationalInfo><internationOpenDate>2024.07.11</internationOpenDate><internationOpenNumber>WO2024145791</internationOpenNumber><internationalApplicationDate>2023.01.03</internationalApplicationDate><internationalApplicationNumber>PCT/CN2023/070230</internationalApplicationNumber></internationalInfo></internationalInfoArray><claimInfoArray><claimInfo><claim>1. 디코딩 방법으로서,비트스트림을 기반으로 현재 시퀀스 중 현재 블록의 잔차 블록을 결정하는 단계;인트라 템플릿 매칭 예측(IntraTMP) 모드를 기반으로 상기 현재 블록의 적어도 하나의 매칭 블록을 예측하는 단계;상기 적어도 하나의 매칭 블록을 기반으로 상기 현재 블록의 목표 예측 블록을 결정하는 단계; 및상기 현재 블록의 잔차 블록과 상기 목표 예측 블록을 기반으로 상기 현재 블록의 재구성 블록을 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>2. 제1항에 있어서,상기의, 인트라 템플릿 매칭 예측(IntraTMP) 모드를 기반으로 상기 현재 블록의 적어도 하나의 매칭 블록을 예측하는 단계는,상기 비트스트림을 기반으로 제1 식별자를 결정하는 단계; 및상기 제1 식별자가 IntraTMP 모드를 사용한 융합 예측을 지시하는 경우, 상기 IntraTMP 모드를 기반으로 상기 적어도 하나의 매칭 블록을 예측하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>3. 제2항에 있어서,상기의, 상기 비트스트림을 기반으로 제1 식별자를 결정하는 단계는,상기 비트스트림을 기반으로 제2 식별자를 결정하는 단계; 및상기 제2 식별자가 IntraTMP 모드를 사용한 예측을 지시하는 경우, 상기 비트스트림을 기반으로 상기 제1 식별자를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>4. 제2항에 있어서,상기의, 상기 비트스트림을 기반으로 제1 식별자를 결정하는 단계는,목표 컨텍스트 인덱스를 결정하는 단계; 및상기 비트스트림을 기반으로, 상기 목표 컨텍스트 인덱스를 사용하여 상기 제1 식별자를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>5. 제4항에 있어서,상기의, 목표 컨텍스트 인덱스를 결정하는 단계는,상기 현재 블록의 인접 디코딩 블록의 디코딩 정보를 기반으로 상기 목표 컨텍스트 인덱스를 결정하는 단계; 및/또는상기 현재 블록의 크기를 기반으로 상기 목표 컨텍스트 인덱스를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>6. 제5항에 있어서,상기 현재 블록의 좌표가 (x, y)이고, 상기 인접 디코딩 블록은 좌표가 (x-1, y)인 제1 디코딩 블록과 좌표가 (x, y-1)인 제2 디코딩 블록을 포함하며; 상기 제1 디코딩 블록의 디코딩 정보는 상기 제1 디코딩 블록의 예측 블록에 사용된 예측 모드를 포함하고, 상기 제2 디코딩 블록의 디코딩 정보는 상기 제2 디코딩 블록의 예측 블록에 사용된 예측 모드를 포함하며;상기의, 상기 현재 블록의 인접 디코딩 블록의 디코딩 정보를 기반으로 상기 목표 컨텍스트 인덱스를 결정하는 단계는,상기 제1 디코딩 블록의 예측 블록에 사용된 예측 모드가 상기 IntraTMP 모드를 기반으로 융합 예측을 수행하는 모드인 경우, 제1 수치를 A로 설정하고, 그렇지 않은 경우, 상기 제1 수치를 B로 설정하는 단계 - A와 B는 정수임 - ;상기 제2 디코딩 블록의 예측 블록에 사용된 예측 모드가 상기 IntraTMP 모드를 기반으로 융합 예측을 수행하는 모드인 경우, 제2 수치를 C로 설정하고, 그렇지 않은 경우, 상기 제2 수치를 D로 설정하는 단계 - C와 D는 정수임 - ; 및상기 제1 수치와 상기 제2 수치의 합을 상기 목표 컨텍스트 인덱스로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>7. 제1항 내지 제6항 중 어느 한 항에 있어서,상기의, 인트라 템플릿 매칭 예측(IntraTMP) 모드를 기반으로 상기 현재 블록의 적어도 하나의 매칭 블록을 예측하는 단계는,상기 IntraTMP 모드를 기반으로 상기 현재 블록에 대해 템플릿 매칭을 수행하여 X개의 후보 매칭 블록을 얻는 단계;상기 X개의 후보 매칭 블록을 기반으로 상기 적어도 하나의 매칭 블록을 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>8. 제7에 있어서,상기의, 상기 IntraTMP 모드를 기반으로 상기 현재 블록에 대한 템플릿 매칭을 수행하여 X개의 후보 매칭 블록을 얻는 단계는,상기 IntraTMP 모드를 기반으로, 상기 현재 블록의 검색 영역 내에서 인트라 템플릿 매칭을 수행하여 상기 현재 블록의 모든 후보 매칭 블록을 얻는 단계; 및템플릿 오차값의 오름차순으로 상위 X개 위치의 매칭 블록을 상기 X개의 후보 매칭 블록으로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>9. 제7항에 있어서,상기의, 상기 IntraTMP 모드를 기반으로 상기 현재 블록에 대한 템플릿 매칭을 수행하여 X개의 후보 매칭 블록을 얻는 단계는,상기 IntraTMP 모드를 기반으로 후보 매칭 블록 리스트를 구성하는 단계를 포함하되,상기 후보 매칭 블록 리스트는 상기 현재 블록의 검색 영역 내에서 인트라 템플릿 매칭 시 매치된, 템플릿 오차값이 가장 작은 X개의 매칭 블록을 저장하도록 구성되는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>10. 제9항에 있어서,상기의, 상기 IntraTMP 모드를 기반으로 상기 현재 블록에 대해 템플릿 매칭을 수행하여 X개의 후보 매칭 블록을 얻는 단계는,상기 현재 블록의 검색 영역을 Y개의 서브 영역으로 분할하는 단계; 및상기 IntraTMP 모드를 기반으로, 상기 Y개의 서브 영역 중 각 서브 영역 내에서 인트라 템플릿 매칭을 수행하여 상기 각 서브 영역 내의 후보 매칭 블록을 얻는 단계를 포함하되,상기 X개의 후보 매칭 블록은 상기 각 서브 영역 내의 후보 매칭 블록을 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>11. 제10항에 있어서,X=Y이거나, 또는 X가 Y의 배수인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>12. 제7항 내지 제11항 중 어느 한 항에 있어서,상기의, 상기 X개의 후보 매칭 블록을 기반으로 상기 적어도 하나의 매칭 블록을 결정하는 단계는,상기 X개의 후보 매칭 블록을 기반으로 N개의 사용 가능한 매칭 블록을 결정하는 단계 - X≥N임 - ; 및상기 N개의 사용 가능한 매칭 블록을 기반으로 상기 적어도 하나의 매칭 블록을 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>13. 제12항에 있어서,X가 N의 배수인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>14. 제12항에 있어서,상기의, 상기 X개의 후보 매칭 블록을 기반으로 N개의 사용 가능한 매칭 블록을 결정하는 단계는,상기 X개의 후보 매칭 블록 사이의 간격을 기반으로 상기 X개의 후보 매칭 블록을 프루닝하여 상기 N개의 사용 가능한 매칭 블록을 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>15. 제14항에 있어서,상기의, 상기 X개의 후보 매칭 블록 사이의 간격을 기반으로 상기 X개의 후보 매칭 블록을 프루닝하여 상기 N개의 사용 가능한 매칭 블록을 얻는 단계는,템플릿 오차값의 오름차순으로, 상기 X개의 후보 매칭 블록 중의, 프루닝에 사용될 현재 후보 매칭 블록을 결정하는 단계;상기 현재 후보 매칭 블록의 프루닝 범위를 결정하는 단계; 및상기 프루닝 범위 내의, 상기 현재 후보 매칭 블록을 제외한 다른 후보 매칭 블록을 제거하여, 상기 현재 후보 매칭 블록을 기반으로 프루닝한 후 남은 후보 매칭 블록을 얻는 것을, 상기 X개의 후보 매칭 블록의 프루닝 횟수가 N이 될 때까지 수행하고 남은 후보 매칭 블록 중 상위 N개의 후보 매칭 블록을 상기 N개의 사용 가능한 매칭 블록으로 결정하거나, 또는 상기 현재 후보 매칭 블록을 기반으로 프루닝한 후 남은 후보 매칭 블록의 수가 N보다 작거나 같을 때까지 수행하고, 지난 회 프루닝한 후 남은 후보 매칭 블록 중 상위 N개의 후보 매칭 블록을 상기 N개의 사용 가능한 매칭 블록으로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>16. 제15항에 있어서,상기의, 상기 현재 후보 매칭 블록의 프루닝 범위를 결정하는 단계는,상기 현재 블록의 크기 및 상기 현재 후보 매칭 블록을 기반으로 상기 프루닝 범위를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>17. 제16항에 있어서,상기의, 상기 현재 블록의 크기 및 상기 현재 후보 매칭 블록을 기반으로 상기 프루닝 범위를 결정하는 단계는,상기 현재 블록으로부터 상기 현재 후보 매칭 블록을 가리키는 블록 벡터를 중심으로, (S/E)*H를 상기 프루닝 범위로 결정하는 단계를 포함하되,여기서, /는 나눗셈 연산자이고, *는 곱셈 연산자이고, S는 상기 X개의 후보 매칭 블록에 사용된 매칭 스텝 크기이고, H는 상기 현재 블록의 높이이고, E는 양의 정수인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>18. 제15항에 있어서,상기의, 상기 현재 후보 매칭 블록의 프루닝 범위를 결정하는 단계는,미리 정의된 수치를 기반으로 상기 프루닝 범위를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>19. 제12항에 있어서,상기의, 상기 X개의 후보 매칭 블록을 기반으로 N개의 사용 가능한 매칭 블록을 결정하는 단계는,상기 X개의 후보 매칭 블록을 리파인하여 상기 N개의 사용 가능한 매칭 블록을 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>20. 제19항에 있어서,상기의, 상기 X개의 후보 매칭 블록을 리파인하여 상기 N개의 사용 가능한 매칭 블록을 얻는 단계는,상기 X개의 후보 매칭 블록 중 현재 후보 매칭 블록의 리파인 범위를 결정하는 단계;적어도 하나의 매칭 스텝 크기를 사용하여 상기 리파인 범위 내에서 인트라 템플릿 매칭을 수행하여 리파인 범위 내에서 매치된 매칭 블록을 얻는 단계 - 상기 적어도 하나의 매칭 스텝 크기 중의 각 매칭 스텝 크기는 모두 상기 X개의 후보 매칭 블록에 사용된 매칭 스텝 크기보다 작음 - ;상기 리파인 범위 내에서 매치된 매칭 블록 중 템플릿 손실값이 가장 작은 매칭 블록을, 상기 현재 후보 매칭 블록을 리파인하여 얻은 후보 매칭 블록으로 결정하는 단계; 및상기 현재 후보 매칭 블록을 리파인하여 얻은 후보 매칭 블록을, 상기 N개의 사용 가능한 매칭 블록 중의 사용 가능한 매칭 블록으로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>21. 제20항에 있어서,상기의, 상기 X개의 후보 매칭 블록 중 현재 후보 매칭 블록의 리파인 범위를 결정하는 단계는,상기 현재 블록의 크기 및 상기 현재 후보 매칭 블록을 기반으로 상기 리파인 범위를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>22. 제21항에 있어서,상기의, 상기 현재 블록의 크기 및 상기 현재 후보 매칭 블록을 기반으로 상기 리파인 범위를 결정하는 단계는,상기 현재 블록으로부터 상기 현재 후보 매칭 블록을 가리키는 블록 벡터를 중심으로, (S/F)*H를 상기 리파인 범위로 결정하는 단계를 포함하되,여기서, /는 나눗셈 연산자이고, *는 곱셈 연산자이고, S는 상기 X개의 후보 매칭 블록에 사용된 매칭 스텝 크기이고, H는 상기 현재 블록의 높이이고, F는 양의 정수인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>23. 제20항에 있어서,상기의, 상기 X개의 후보 매칭 블록 중 현재 후보 매칭 블록의 리파인 범위를 결정하는 단계는,미리 정의된 수치를 기반으로 상기 리파인 범위를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>24. 제20항에 있어서,상기의, 상기 리파인 범위 내에서 매치된 매칭 블록 중 템플릿 손실값이 가장 작은 매칭 블록을, 상기 현재 후보 매칭 블록을 리파인하여 얻은 후보 매칭 블록으로 결정하는 단계는,상기 현재 후보 매칭 블록이 상기 X개의 후보 매칭 블록 중의 i번째 매칭 블록이고, 상기 리파인 범위 내에서 매치된 j번째 매칭 블록이 상기 리파인 범위 내에서의 상위 j개의 매칭 블록 중 템플릿 손실값이 가장 작은 매칭 블록이면, 상기 X개의 후보 매칭 블록 중 상위 i-1개의 후보 매칭 블록을 리파인하여 얻은 후보 매칭 블록이 상기 j번째 매칭 블록을 포함하지 않는 경우에, 상기 j번째 매칭 블록을, 상기 현재 후보 매칭 블록을 리파인하여 얻은 후보 매칭 블록으로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>25. 제12항에 있어서,상기의, 상기 X개의 후보 매칭 블록을 기반으로 N개의 사용 가능한 매칭 블록을 결정하는 단계는,상기 X개의 후보 매칭 블록에 대해 프루닝 및 리파인을 수행하여 상기 N개의 사용 가능한 매칭 블록을 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>26. 제25항에 있어서,상기의, 상기 X개의 후보 매칭 블록에 대해 프루닝 및 리파인을 수행하여 상기 N개의 사용 가능한 매칭 블록을 얻는 단계는,상기 X개의 후보 매칭 블록을 프루닝한 후, 프루닝된 후보 매칭 블록을 리파인하는 단계; 또는상기 X개의 후보 매칭 블록을 리파인한 후, 리파인된 후보 매칭 블록을 프루닝하는 단계; 또는상기 X개의 후보 매칭 블록 중의 현재 후보 매칭 블록을 기반으로 상기 X개의 후보 매칭 블록을 1회 프루닝한 후, 상기 현재 후보 매칭 블록을 리파인하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>27. 제12항 내지 제26항 중 어느 한 항에 있어서,상기의, 상기 N개의 사용 가능한 매칭 블록을 기반으로 상기 적어도 하나의 매칭 블록을 결정하는 단계는,상기 N개의 사용 가능한 매칭 블록에 사용된 융합 조건을 결정하는 단계; 및상기 N개의 사용 가능한 매칭 블록 중의, 상기 융합 조건을 만족하는 사용 가능한 매칭 블록을 상기 적어도 하나의 매칭 블록으로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>28. 제27항에 있어서,상기의, 상기 N개의 사용 가능한 매칭 블록에 사용된 융합 조건을 결정하는 단계는,상기 현재 블록의 템플릿 크기, 상기 현재 블록 중 현재 블록의 픽셀의 비트 폭, 상기 N개의 사용 가능한 매칭 블록의 최소 템플릿 오차값 중 적어도 하나를 기반으로 상기 융합 조건을 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>29. 제28항에 있어서,상기 융합 조건은 제1 임계값을 포함하며, 상기 제1 임계값은 상기 현재 블록의 템플릿 크기 및 상기 비트 폭을 기반으로 결정된 임계값이며;상기의, 상기 N개의 사용 가능한 매칭 블록 중 상기 융합 조건을 만족하는 사용 가능한 매칭 블록을 상기 적어도 하나의 매칭 블록으로 결정하는 단계는,상기 N개의 사용 가능한 매칭 블록 중 템플릿 오차값이 상기 제1 임계값보다 작거나 같은 사용 가능한 매칭 블록을 상기 적어도 하나의 매칭 블록으로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>30. 제29항에 있어서,상기 제1 임계값은 아래의 수식에 의해 결정되는 것을 특징으로 하는 방법.T1=n1003c#003c#(bdepth-n2)*ntemplate여기서, 003c#003c#는 좌측 시프트 연산자이고, -는 뺄셈 연산자이고, *는 곱셈 연산자이고, T1은 상기 제1 임계값을 나타내고, bdepth는 상기 비트 폭을 나타내고, ntemplate는 상기 현재 블록의 템플릿 중 픽셀의 수를 나타내며; n1 및 n2는 양의 정수임.</claim></claimInfo><claimInfo><claim>31. 제28항 내지 제30항 중 어느 한 항에 있어서,상기 융합 조건은 제2 임계값을 포함하며, 상기 제2 임계값은 상기 최소 템플릿 오차값을 기반으로 결정된 임계값이며;상기의, 상기 N개의 사용 가능한 매칭 블록 중 상기 융합 조건을 만족하는 사용 가능한 매칭 블록을 상기 적어도 하나의 매칭 블록으로 결정하는 단계는,상기 N개의 사용 가능한 매칭 블록 중 템플릿 오차값이 상기 제2 임계값보다 작거나 같은 사용 가능한 매칭 블록을 상기 적어도 하나의 매칭 블록으로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>32. 제31항에 있어서,상기 제2 임계값은 아래의 수식에 의해 결정되는 것을 특징으로 하는 방법.T2=minSAD003c#003c#n3여기서, 003c#003c#는 좌측 시프트 연산자이고, T2은 상기 제2 임계값을 나타내고, minSAD는 상기 최소 템플릿 오차값을 나타내고, n3은 양의 정수임.</claim></claimInfo><claimInfo><claim>33. 제12항 내지 제26항 중 어느 한 항에 있어서,상기의, 상기 N개의 사용 가능한 매칭 블록을 기반으로 상기 적어도 하나의 매칭 블록을 결정하는 단계는,상기 비트스트림을 기반으로 지시 정보를 결정하는 단계 - 상기 지시 정보는 상기 N개의 사용 가능한 매칭 블록에서 상기 적어도 하나의 매칭 블록을 지시하도록 구성됨 - ; 및상기 지시 정보를 기반으로 상기 적어도 하나의 매칭 블록을 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>34. 제1항 내지 제33항 중 어느 한 항에 있어서,상기의, 상기 적어도 하나의 매칭 블록을 기반으로 상기 목표 예측 블록을 결정하는 단계는,상기 적어도 하나의 매칭 블록이 복수의 매칭 블록인 경우, 상기 복수의 매칭 블록에 대해 가중 처리를 수행하여 상기 현재 블록의 목표 예측 블록을 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>35. 제34항에 있어서,상기의, 상기 복수의 매칭 블록에 대해 가중 처리를 수행하여 상기 목표 예측 블록을 얻는 단계는,상기 복수의 매칭 블록 중 각 매칭 블록의 가중치를 결정하는 단계; 및상기 각 매칭 블록의 가중치를 기반으로, 상기 복수의 매칭 블록에 대해 가중 처리를 수행하여 상기 목표 예측 블록을 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>36. 제35항에 있어서,상기의, 상기 복수의 매칭 블록 중 각 매칭 블록의 가중치를 결정하는 단계는,상기 각 매칭 블록의 템플릿 오차값, 상기 복수의 매칭 블록의 수, 및 상기 복수의 매칭 블록의 가중치의 합을 기반으로, 상기 각 매칭 블록의 가중치를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>37. 제36항에 있어서,상기의, 상기 각 매칭 블록의 템플릿 오차값, 상기 복수의 매칭 블록의 수, 및 상기 복수의 매칭 블록의 가중치의 합을 기반으로, 상기 각 매칭 블록의 가중치를 결정하는 단계는,상기 각 매칭 블록의 템플릿 오차값을 기반으로, 각 매칭 블록에 대응하는 제3 수치를 결정하는 단계;상기 각 매칭 블록에 대응하는 제3 수치를 합산하여 제4 수치를 얻는 단계; 및상기 제4 수치와 상기 각 매칭 블록의 템플릿 오차값을 기반으로, 상기 각 매칭 블록의 가중치를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>38. 제37항에 있어서,상기의, 상기 각 매칭 블록의 템플릿 오차값을 기반으로, 각 매칭 블록에 대응하는 제3 수치를 결정하는 단계는,상기 복수의 매칭 블록 중 i번째 매칭 블록의 템플릿 오차값이 0인 경우, 0보다 큰 기설정된 값을 상기 i번째 매칭 블록에 대응하는 제3 수치로 결정하는 단계; 및상기 i번째 매칭 블록의 템플릿 오차값이 0인 경우, 상기 i번째 매칭 블록의 템플릿 오차값을 상기 i번째 매칭 블록에 대응하는 제3 수치로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>39. 제37항에 있어서,상기의, 상기 제4 수치 및 상기 각 매칭 블록의 템플릿 오차값을 기반으로, 상기 각 매칭 블록의 가중치를 결정하는 단계는,상기 제4 수치에서 상기 i번째 매칭 블록에 대응하는 제3 수치를 빼서 제5 수치를 얻는 것,상기 제4 수치에 n-1을 곱하여 제6 수치를 얻는 것 - n은 상기 복수의 매칭 블록의 수를 나타냄 -, 및상기 제5 수치 및 상기 제6 수치를 기반으로, 상기 i번째 매칭 블록의 가중치를 결정하는 것을 포함하는 방식에 따라, 상기 복수의 매칭 블록 중 i번째 매칭 블록의 가중치를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>40. 제39항에 있어서,상기의, 상기 제5 수치 및 상기 제6 수치를 기반으로, 상기 i번째 매칭 블록의 가중치를 결정하는 것은,상기 i번째 매칭 블록이 상기 복수의 매칭 블록 중 마지막 매칭 블록이 아닌 경우, 상기 제5 수치와 제6 수치의 비율값을 상기 i번째 매칭 블록의 가중치로 결정하는 단계; 및상기 i번째 매칭 블록이 상기 마지막 매칭 블록인 경우, 기설정된 가중치 총합에서 상기 복수의 매칭 블록 중 상위 n-1개의 매칭 블록의 가중치를 빼서 상기 마지막 매칭 블록의 가중치를 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>41. 제39항에 있어서,상기의, 상기 제5 수치 및 상기 제6 수치를 기반으로, 상기 i번째 매칭 블록의 가중치를 결정하는 것은,상기 제5 수치와 상기 제6 수치의 비율값을 상기 i번째 매칭 블록의 가중치로 결정하는 단계를 포함하되,여기서, 상기 복수의 매칭 블록의 가중치의 합은 기설정된 가중치 총합과 같은 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>42. 제40항 또는 제41항에 있어서,상기 제5 수치와 상기 제6 수치의 비율값은 비트 연산, 덧셈 연산 및 뺄셈 연산을 사용하여 얻은 수치인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>43. 제42항에 있어서,상기 제5 수치 및 상기 제6 수치의 비율값은 아래의 수식에 의해 결정된 수치인 것을 특징으로 하는 방법.Wi=(D5*V*Wsum+DAdd)003e#003e#DShift여기서, *는 곱셈 연산자이고, +는 덧셈 연산자이고, 003e#003e#는 우측 시프트 연산자이고, D5는 상기 제5 수치를 나타내고, Wsum은 상기 가중치 총합을 나타내고, V는 제7 수치를 기반으로 테이블을 조회하여 결정된 수치이고, DShift는 상기 제7 수치를 기반으로 계산하여 결정된 우측 시프트량이고, 상기 제7 수치는 상기 제6 수치를 기반으로 결정된 수치이고, DAdd는 DShift를 기반으로 결정된 수치임.</claim></claimInfo><claimInfo><claim>44. 제43항에 있어서,V 및 DShift는 아래의 방식에 의해 결정되는 것을 특징으로 하는 방법.X=,D7=((n-1)*D4003c#003c#4003e#003e#X)0026#15,V=table[D7]|8,X=D7==0?X:X+1,DShift=X+3,여기서, 는 올림 연산자이고, *는 곱셈 연산자이고, 003c#003c#는 좌측 시프트 연산자이고, 003e#003e#는 우측 시프트 연산자이고, 0026#는 논리 AND 연산자이고, |는 논리 OR 연산자이고, ?는 조건 연산자이고, +는 덧셈 연산자이고, D6은 상기 제6 수치를 나타내고, D4는 상기 제4 수치를 나타내고, table[]은 테이블 조회를 나타내고, D7은 상기 제7 수치를 나타냄.</claim></claimInfo><claimInfo><claim>45. 제43항에 있어서,DAdd=1003c#003c#(DShift-1)이거나，또는 DAdd=1003c#003c#DShift이며,여기서, 003c#003c#는 좌측 시프트 연산자이고, -는 뺄셈 연산자인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>46. 제35항에 있어서,상기의, 상기 복수의 매칭 블록 중 각 매칭 블록의 가중치를 결정하는 단계는,상기 복수의 매칭 블록의 수를 기반으로, 포함된 가중치가 상기 복수의 매칭 블록의 수와 같은 제1 후보 집합을 복수의 후보 집합 중에서 선택하는 단계 - 상기 복수의 후보 집합 중의 각 후보 집합은 적어도 하나의 후보 가중치를 포함함 - ; 및상기 제1 후보 집합을 기반으로, 상기 각 매칭 블록의 가중치를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>47. 제46항에 있어서,상기 각 매칭 블록의 템플릿 오차값과 상기 각 매칭 블록의 가중치는 음의 상관 관계가 있는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>48. 제34항에 있어서,상기의, 상기 각 매칭 블록의 가중치를 기반으로 상기 복수의 매칭 블록에 대해 가중 처리를 수행하여 상기 목표 예측 블록을 얻는 단계는,상기 각 매칭 블록에 상기 각 매칭 블록의 가중치를 곱한 후 합산하여 제8 수치를 얻는 단계;상기 제8 수치에 Coffset을 더하여 제9 수치를 얻는 단계; 및상기 제9 수치를 CShift만큼 우측 시프트하여 상기 목표 예측 블록을 얻는 단계를 포함하되,여기서, Coffset은 CShift에 의해 결정된 수치이며, CShift는 상기 복수의 매칭 블록의 가중치의 합에 의해 결정된 수치인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>49. 제48항에 있어서,Coffset=003c#003c#(CShift-1)이고, CShift=이며,여기서, 은 올림 연산자이고, 003c#003c#는 좌측 시프트 연산자이고, Wsum은 상기 복수의 매칭 블록의 가중치의 합을 나타내는 것을특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>50. 제34항에 있어서,상기의, 상기 복수의 매칭 블록에 대해 가중 처리를 수행하여 상기 현재 블록의 목표 예측 블록을 얻는 단계는,상기 현재 블록을 복수의 영역으로 분할하는 단계;상기 복수의 영역 중의 제1 영역에 대해, 상기 복수의 매칭 블록 중 각 매칭 블록이 상기 제1 영역에서 가지는 가중치를 결정하는 단계; 및상기 각 매칭 블록이 제1 영역에서 가지는 가중치를 기반으로, 상기 제1 영역에서 상기 복수의 매칭 블록에 대해 가중 처리를 수행하여 상기 목표 예측 블록이 상기 제1 영역에서 가지는 예측값을 얻는 단계를 포함하되,여기서, 상기 목표 예측 블록은 상기 복수의 영역 중 각 영역에서의 예측값을 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>51. 제50항에 있어서,상기의, 상기 현재 블록을 복수의 영역으로 분할하는 단계는,수평 방향 또는 수직 방향으로 상기 현재 블록을 복수의 영역으로 분할하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>52. 제1항 내지 제33항 중 어느 한 항에 있어서,상기의, 상기 적어도 하나의 매칭 블록을 기반으로 상기 현재 블록의 목표 예측 블록을 결정하는 단계는,상기 적어도 하나의 매칭 블록이 단일 매칭 블록인 경우, 제1 인트라 예측 모드를 사용하여 상기 현재 블록을 예측하여 제1 예측 블록을 얻는 단계; 및상기 단일 매칭 블록과 제1 예측 블록에 대해 가중 처리를 수행하여 상기 목표 예측 블록을 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>53. 제52항에 있어서,상기 단일 매칭 블록의 가중치와 상기 제1 예측 블록의 가중치는 모두 미리 정의된 가중치인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>54. 제52항에 있어서,인접 디코딩 블록의 디코딩 정보, 상기 현재 블록의 크기, 상기 현재 블록의 템플릿 크기, 상기 제1 인트라 예측 모드의 유형, 및 상기 현재 블록의 각 영역의 위치 중 적어도 하나를 기반으로, 상기 단일 매칭 블록의 가중치와 상기 제1 예측 블록의 가중치를 결정하는 단계를 더 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>55. 제1항 내지 제33항 중 어느 한 항에 있어서,상기의, 상기 적어도 하나의 매칭 블록을 기반으로 상기 현재 블록의 목표 예측 블록을 결정하는 단계는,상기 적어도 하나의 매칭 블록이 복수의 매칭 블록인 경우, 제2 인트라 예측 모드를 사용하여 상기 현재 블록을 예측하여 제2 예측 블록을 얻는 단계; 및상기 복수의 매칭 블록과 제2 예측 블록에 대해 가중 처리를 수행하여 상기 목표 예측 블록을 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>56. 제55항에 있어서,상기 제2 예측 블록의 가중치는 미리 정의된 가중치인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>57. 제55항에 있어서,인접 디코딩 블록의 디코딩 정보, 상기 현재 블록의 크기, 상기 현재 블록의 템플릿 크기, 상기 제2 인트라 예측 모드의 유형, 상기 복수의 매칭 블록의 가중치 총합, 및 상기 현재 블록의 각 영역의 위치 중 적어도 하나를 기반으로, 상기 제2 예측 블록의 가중치를 결정하는 단계를 더 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>58. 제1항 내지 제57항 중 어느 한 항에 있어서,상기 현재 블록의 템플릿은 좌측 재구성 픽셀, 좌하측 재구성 픽셀, 좌상측 재구성 픽셀, 상측 재구성 픽셀, 우상측 재구성 픽셀 중 적어도 하나를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>59. 제1항 내지 제58항 중 어느 한 항에 있어서,상기의, 인트라 템플릿 매칭 예측(IntraTMP) 모드를 기반으로 상기 현재 블록의 적어도 하나의 매칭 블록을 예측하는 단계는,상기 IntraTMP 모드의 사용 제한 조건을 결정하는 단계; 및상기 제한 조건이 충족되는 경우, 상기 IntraTMP 모드를 기반으로 상기 적어도 하나의 매칭 블록을 예측하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>60. 제59항에 있어서,상기 제한 조건은, 현재 블록의 크기, 인접 디코딩 블록의 디코딩 정보, 시퀀스 레벨 플래그 비트, 프레임 레벨 플래그 비트, 매크로블록 레벨 플래그 비트, 상기 현재 블록이 속한 슬라이스 유형, 상기 현재 블록이 속한 이미지 프레임의 프레임 유형 중 적어도 하나로부터 도출된 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>61. 인코딩 방법으로서,인트라 템플릿 매칭 예측(IntraTMP) 모드를 기반으로 현재 시퀀스 중 현재 블록의 적어도 하나의 매칭 블록을 예측하는 단계;상기 적어도 하나의 매칭 블록을 기반으로 상기 현재 블록의 목표 예측 블록을 결정하는 단계;상기 목표 예측 블록과 상기 현재 블록의 원본 블록을 기반으로 상기 현재 블록의 잔차 블록을 얻는 단계; 및상기 현재 블록의 잔차 블록을 인코딩하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>62. 제61항에 있어서,제1 식별자를 인코딩하는 단계를 더 포함하되,여기서, 상기 제1 식별자는, 상기 IntraTMP 모드를 사용하여 융합 예측을 수행하는 것을 지시하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>63. 제62항에 있어서,제2 식별자를 인코딩하는 단계를 더 포함하되,여기서, 상기 제2 식별자는, IntraTMP 모드를 사용하여 예측을 수행하는 것을 지시하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>64. 제62항에 있어서,상기 제2 식별자를 인코딩하는 단계는,목표 컨텍스트 인덱스를 결정하는 단계; 및상기 목표 컨텍스트 인덱스를 사용하여 상기 제1 식별자를 인코딩하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>65. 제64항에 있어서,상기의, 목표 컨텍스트 인덱스를 결정하는 단계는,상기 현재 블록의 인접 인코딩 블록의 인코딩 정보를 기반으로 상기 목표 컨텍스트 인덱스를 결정하는 단계; 및/또는상기 현재 블록의 크기를 기반으로 상기 목표 컨텍스트 인덱스를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>66. 제65항에 있어서,상기 현재 블록의 좌표가 (x, y)이고, 상기 인접 인코딩 블록은 좌표가 (x-1, y)인 제1 인코딩 블록과 좌표가 (x, y-1)인 제2 인코딩 블록을 포함하며; 상기 제1 인코딩 블록의 인코딩 정보는 상기 제1 인코딩 블록의 예측 블록에 사용된 예측 모드를 포함하고, 상기 제2 인코딩 블록의 인코딩 정보는 상기 제2 인코딩 블록의 예측 블록에 사용된 예측 모드를 포함하며;상기의, 상기 현재 블록의 인접 인코딩 블록의 인코딩 정보를 기반으로 상기 목표 컨텍스트 인덱스를 결정하는 단계는,상기 제1 인코딩 블록의 예측 블록에 사용된 예측 모드가 상기 IntraTMP 모드를 기반으로 융합 예측을 수행하는 모드인 경우, 제1 수치를 A로 설정하고, 그렇지 않은 경우, 상기 제1 수치를 B로 설정하는 단계 - A와 B는 정수임 - ;상기 제2 인코딩 블록의 예측 블록에 사용된 예측 모드가 상기 IntraTMP 모드를 기반으로 융합 예측을 수행하는 모드인 경우, 제2 수치를 C로 설정하고, 그렇지 않은 경우, 상기 제2 수치를 D로 설정하는 단계 - C와 D는 정수임 - ; 및상기 제1 수치와 상기 제2 수치의 합을 상기 목표 컨텍스트 인덱스로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>67. 제61항 내지 제66항 중 어느 한 항에 있어서,상기의, 인트라 템플릿 매칭 예측(IntraTMP) 모드를 기반으로 현재 시퀀스 중 현재 블록의 적어도 하나의 매칭 블록을 예측하는 단계는,상기 IntraTMP 모드를 기반으로 상기 현재 블록에 대해 템플릿 매칭을 수행하여 X개의 후보 매칭 블록을 얻는 단계; 및상기 X개의 후보 매칭 블록을 기반으로 상기 적어도 하나의 매칭 블록을 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>68. 제67항에 있어서,상기의, 상기 IntraTMP 모드를 기반으로 상기 현재 블록에 대해 템플릿 매칭을 수행하여 X개의 후보 매칭 블록을 얻는 단계는,상기 IntraTMP 모드를 기반으로, 상기 현재 블록의 검색 영역 내에서 인트라 템플릿 매칭을 수행하여 상기 현재 블록의 모든 후보 매칭 블록을 얻는 단계; 및템플릿 오차값의 오름차순으로 상위 X개 위치의 매칭 블록을 상기 X개의 후보 매칭 블록으로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>69. 제67항에 있어서,상기의, 상기 IntraTMP 모드를 기반으로 상기 현재 블록에 대해 템플릿 매칭을 수행하여 X개의 후보 매칭 블록을 얻는 단계는,상기 IntraTMP 모드를 기반으로 후보 매칭 블록 리스트를 구성하는 단계를 포함하되,상기 후보 매칭 블록 리스트는 상기 현재 블록의 검색 영역 내에서 인트라 템플릿 매칭 시 매치된, 템플릿 오차값이 가장 작은 X개의 매칭 블록을 저장하도록 구성되는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>70. 제69항에 있어서,상기의, 상기 IntraTMP 모드를 기반으로 상기 현재 블록에 대해 템플릿 매칭을 수행하여 X개의 후보 매칭 블록을 얻는 단계는,상기 현재 블록의 검색 영역을 Y개의 서브 영역으로 분할하는 단계; 및상기 IntraTMP 모드를 기반으로, 상기 Y개의 서브 영역 중 각 서브 영역 내에서 인트라 템플릿 매칭을 수행하여 상기 각 서브 영역 내의 후보 매칭 블록을 얻는 단계를 포함하되,상기 X개의 후보 매칭 블록은 상기 각 서브 영역 내의 후보 매칭 블록을 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>71. 제70항에 있어서,X=Y이거나, 또는 X가 Y의 배수인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>72. 제67항 내지 제71항 중 어느 한 항에 있어서,상기의, 상기 X개의 후보 매칭 블록을 기반으로 상기 적어도 하나의 매칭 블록을 결정하는 단계는,상기 X개의 후보 매칭 블록을 기반으로 N개의 사용 가능한 매칭 블록을 결정하는 단계 - X≥N임 - ; 및상기 N개의 사용 가능한 매칭 블록을 기반으로 상기 적어도 하나의 매칭 블록을 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>73. 제72항에 있어서,X가 N의 배수인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>74. 제72항에 있어서,상기의, 상기 X개의 후보 매칭 블록을 기반으로 N개의 사용 가능한 매칭 블록을 결정하는 단계는,상기 X개의 후보 매칭 블록 사이의 간격을 기반으로 상기 X개의 후보 매칭 블록을 프루닝하여 상기 N개의 사용 가능한 매칭 블록을 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>75. 제74항에 있어서,상기의, 상기 X개의 후보 매칭 블록 사이의 간격을 기반으로 상기 X개의 후보 매칭 블록을 프루닝하여 상기 N개의 사용 가능한 매칭 블록을 얻는 단계는,템플릿 오차값의 오름차순으로, 상기 X개의 후보 매칭 블록 중의, 프루닝에 사용될 현재 후보 매칭 블록을 결정하는 단계;상기 현재 후보 매칭 블록의 프루닝 범위를 결정하는 단계; 및상기 프루닝 범위 내의, 상기 현재 후보 매칭 블록을 제외한 다른 후보 매칭 블록을 제거하여, 상기 현재 후보 매칭 블록을 기반으로 프루닝한 후 남은 후보 매칭 블록을 얻는 것을, 상기 X개의 후보 매칭 블록의 프루닝 횟수가 N이 될 때까지 수행하고 남은 후보 매칭 블록 중 상위 N개의 후보 매칭 블록을 상기 N개의 사용 가능한 매칭 블록으로 결정하거나, 또는 상기 현재 후보 매칭 블록을 기반으로 프루닝한 후 남은 후보 매칭 블록의 수가 N보다 작거나 같을 때까지 수행하고, 지난 회 프루닝한 후 남은 후보 매칭 블록 중 상위 N개의 후보 매칭 블록을 상기 N개의 사용 가능한 매칭 블록으로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>76. 제75항에 있어서,상기의, 상기 현재 후보 매칭 블록의 프루닝 범위를 결정하는 단계는,상기 현재 블록의 크기 및 상기 현재 후보 매칭 블록을 기반으로 상기 프루닝 범위를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>77. 제76항에 있어서,상기의, 상기 현재 블록의 크기 및 상기 현재 후보 매칭 블록을 기반으로 상기 프루닝 범위를 결정하는 단계는,상기 현재 블록으로부터 상기 현재 후보 매칭 블록을 가리키는 블록 벡터를 중심으로, (S/E)*H를 상기 프루닝 범위로 결정하는 단계를 포함하되,여기서, /는 나눗셈 연산자를 나타내고, *는 곱셈 연산자를 나타내고, S는 상기 X개의 후보 매칭 블록에 사용된 매칭 스텝 크기를 나타내고, H는 상기 현재 블록의 높이를 나타내고, E는 양의 정수인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>78. 제75항에 있어서,상기의, 상기 현재 후보 매칭 블록의 프루닝 범위를 결정하는 단계는,미리 정의된 수치를 기반으로 상기 프루닝 범위를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>79. 제72항에 있어서,상기의, 상기 X개의 후보 매칭 블록을 기반으로 N개의 사용 가능한 매칭 블록을 결정하는 단계는,상기 X개의 후보 매칭 블록을 리파인하여 상기 N개의 사용 가능한 매칭 블록을 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>80. 제79항에 있어서,상기의, 상기 X개의 후보 매칭 블록을 리파인하여 상기 N개의 사용 가능한 매칭 블록을 얻는 단계는,상기 X개의 후보 매칭 블록 중 현재 후보 매칭 블록의 리파인 범위를 결정하는 단계;적어도 하나의 매칭 스텝 크기를 사용하여 상기 리파인 범위 내에서 인트라 템플릿 매칭을 수행하여 리파인 범위 내에서 매치된 매칭 블록을 얻는 단계 - 상기 적어도 하나의 매칭 스텝 크기 중의 각 매칭 스텝 크기는 모두 상기 X개의 후보 매칭 블록에 사용된 매칭 스텝 크기보다 작음 - ;상기 리파인 범위 내에서 매치된 매칭 블록 중 템플릿 손실값이 가장 작은 매칭 블록을, 상기 현재 후보 매칭 블록을 리파인하여 얻은 후보 매칭 블록으로 결정하는 단계; 및상기 현재 후보 매칭 블록을 리파인하여 얻은 후보 매칭 블록을, 상기 N개의 사용 가능한 매칭 블록 중의 사용 가능한 매칭 블록으로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>81. 제80항에 있어서,상기의, 상기 X개의 후보 매칭 블록 중 현재 후보 매칭 블록의 리파인 범위를 결정하는 단계는,상기 현재 블록의 크기 및 상기 현재 후보 매칭 블록을 기반으로 상기 리파인 범위를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>82. 제81항에 있어서,상기의, 상기 현재 블록의 크기 및 상기 현재 후보 매칭 블록을 기반으로 상기 리파인 범위를 결정하는 단계는,상기 현재 블록으로부터 상기 현재 후보 매칭 블록을 가리키는 블록 벡터를 중심으로, (S/F)*H를 상기 리파인 범위로 결정하는 단계를 포함하되,여기서, /는 나눗셈 연산자를 나타내고, *는 곱셈 연산자를 나타내고, S는 상기 X개의 후보 매칭 블록에 사용된 매칭 스텝 크기를 나타내고, H는 상기 현재 블록의 높이를 나타내고, F는 양의 정수인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>83. 제80항에 있어서,상기의, 상기 X개의 후보 매칭 블록 중 현재 후보 매칭 블록의 리파인 범위를 결정하는 단계는,미리 정의된 수치를 기반으로 상기 리파인 범위를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>84. 제80항에 있어서,상기의, 상기 리파인 범위 내에서 매치된 매칭 블록 중 템플릿 손실값이 가장 작은 매칭 블록을, 상기 현재 후보 매칭 블록을 리파인하여 얻은 후보 매칭 블록으로 결정하는 단계는,상기 현재 후보 매칭 블록이 상기 X개의 후보 매칭 블록 중의 i번째 매칭 블록이고, 상기 리파인 범위 내에서 매치된 j번째 매칭 블록이 상기 리파인 범위 내에서의 상위 j개의 매칭 블록 중 템플릿 손실값이 가장 작은 매칭 블록이면, 상기 X개의 후보 매칭 블록 중 상위 i-1개의 후보 매칭 블록을 리파인하여 얻은 후보 매칭 블록이 상기 j번째 매칭 블록을 포함하지 않는 경우에, 상기 j번째 매칭 블록을, 상기 현재 후보 매칭 블록을 리파인하여 얻은 후보 매칭 블록으로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>85. 제72항에 있어서,상기의, 상기 X개의 후보 매칭 블록을 기반으로 N개의 사용 가능한 매칭 블록을 결정하는 단계는,상기 X개의 후보 매칭 블록에 대해 프루닝 및 리파인을 수행하여 상기 N개의 사용 가능한 매칭 블록을 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>86. 제85항에 있어서,상기의, 상기 X개의 후보 매칭 블록에 대해 프루닝 및 리파인을 수행하여 상기 N개의 사용 가능한 매칭 블록을 얻는 단계는,상기 X개의 후보 매칭 블록을 프루닝한 후, 프루닝된 후보 매칭 블록을 리파인하는 단계; 또는상기 X개의 후보 매칭 블록을 리파인한 후, 리파인된 후보 매칭 블록을 프루닝하는 단계; 또는상기 X개의 후보 매칭 블록 중의 현재 후보 매칭 블록을 기반으로 상기 X개의 후보 매칭 블록을 1회 프루닝한 후, 상기 현재 후보 매칭 블록을 리파인하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>87. 제72항 내지 제86항 중 어느 한 항에 있어서,상기의, 상기 N개의 사용 가능한 매칭 블록을 기반으로 상기 적어도 하나의 매칭 블록을 결정하는 단계는,상기 N개의 사용 가능한 매칭 블록에 사용된 융합 조건을 결정하는 단계; 및상기 N개의 사용 가능한 매칭 블록 중의, 상기 융합 조건을 만족하는 사용 가능한 매칭 블록을 상기 적어도 하나의 매칭 블록으로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>88. 제87항에 있어서,상기의, 상기 N개의 사용 가능한 매칭 블록에 사용된 융합 조건을 결정하는 단계는,상기 현재 블록의 템플릿 크기, 상기 현재 블록 중 현재 블록 픽셀의 비트 폭, 상기 N개의 사용 가능한 매칭 블록의 최소 템플릿 오차값 중 적어도 하나를 기반으로 상기 융합 조건을 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>89. 제88항에 있어서,상기 융합 조건은 제1 임계값을 포함하되, 상기 제1 임계값은 상기 현재 블록의 템플릿 크기 및 상기 비트 폭을 기반으로 결정된 임계값이며;상기의, 상기 N개의 사용 가능한 매칭 블록 중의, 상기 융합 조건을 만족하는 사용 가능한 매칭 블록을 상기 적어도 하나의 매칭 블록으로 결정하는 단계는,상기 N개의 사용 가능한 매칭 블록 중의, 템플릿 오차값이 상기 제1 임계값보다 작거나 같은 사용 가능한 매칭 블록을 상기 적어도 하나의 매칭 블록으로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>90. 제89항에 있어서,상기 제1 임계값은 아래의 수식에 의해 결정되는 것을 특징으로 하는 방법.T1=n1003c#003c#(bdepth-n2)*ntemplate여기서, 003c#003c#는 좌측 시프트 연산자이고, -는 뺄셈 연산자이고, *는 곱셈 연산자이고, T1은 상기 제1 임계값을 나타내고, bdepth는 상기 비트 폭를 나타내고, ntemplate는 상기 현재 블록의 템플릿 중 픽셀의 수를 나타내고; n1 및 n2는 모두 양의 정수임.</claim></claimInfo><claimInfo><claim>91. 제88항 내지 제90항 중 어느 한 항에 있어서,상기 융합 조건은 제2 임계값을 포함하되, 상기 제2 임계값은 상기 최소 템플릿 오차값을 기반으로 결정된 임계값이며;상기의, 상기 N개의 사용 가능한 매칭 블록 중의, 상기 융합 조건을 만족하는 사용 가능한 매칭 블록을 상기 적어도 하나의 매칭 블록으로 결정하는 단계는,상기 N개의 사용 가능한 매칭 블록 중의, 템플릿 오차값이 상기 제2 임계값보다 작거나 같은 사용 가능한 매칭 블록을 상기 적어도 하나의 매칭 블록으로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>92. 제91항에 있어서,상기 제2 임계값은 아래의 수식에 의해 결정되는 것을 특징으로 하는 방법.T2=minSAD003c#003c#n3여기서, 003c#003c#는 좌측 시프트 연산자이고, T2은 상기 제2 임계값을 나타내고, minSAD는 상기 최소 템플릿 오차값을 나타내고, n3은 양의 정수임.</claim></claimInfo><claimInfo><claim>93. 제72항 내지 제86항 중 어느 한 항에 있어서,지시 정보를 결정하는 단계 - 상기 지시 정보는 상기 N개의 사용 가능한 매칭 블록에서 상기 적어도 하나의 매칭 블록을 지시하도록 구성됨 - ; 및상기 지시 정보를 인코딩하는 단계를 더 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>94. 제61항 내지 제93항 중 어느 한 항에 있어서,상기의, 상기 적어도 하나의 매칭 블록을 기반으로 상기 목표 예측 블록을 결정하는 단계는,상기 적어도 하나의 매칭 블록이 복수의 매칭 블록인 경우, 상기 복수의 매칭 블록에 대해 가중 처리를 수행하여 상기 현재 블록의 목표 예측 블록을 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>95. 제94항에 있어서,상기의, 상기 복수의 매칭 블록에 대해 가중 처리를 수행하여 상기 목표 예측 블록을 얻는 단계는,상기 복수의 매칭 블록 중 각 매칭 블록의 가중치를 결정하는 단계; 및상기 각 매칭 블록의 가중치를 기반으로, 상기 복수의 매칭 블록에 대해 가중 처리를 수행하여 상기 목표 예측 블록을 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>96. 제95항에 있어서,상기의, 상기 복수의 매칭 블록 중 각 매칭 블록의 가중치를 결정하는 단계는,상기 각 매칭 블록의 템플릿 오차값, 상기 복수의 매칭 블록의 수, 및 상기 복수의 매칭 블록의 가중치의 합을 기반으로, 상기 각 매칭 블록의 가중치를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>97. 제96항에 있어서,상기의, 상기 각 매칭 블록의 템플릿 오차값, 상기 복수의 매칭 블록의 수, 및 상기 복수의 매칭 블록의 가중치의 합을 기반으로, 상기 각 매칭 블록의 가중치를 결정하는 단계는,상기 각 매칭 블록의 템플릿 손실값을 기반으로, 각 매칭 블록에 대응하는 제3 수치를 결정하는 단계;상기 각 매칭 블록에 대응하는 제3 수치를 합산하여 제4 수치를 얻는 단계; 및상기 제4 수치와 상기 각 매칭 블록의 템플릿 오차값을 기반으로, 상기 각 매칭 블록의 가중치를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>98. 제97항에 있어서,상기의, 상기 각 매칭 블록의 템플릿 손실값을 기반으로, 각 매칭 블록에 대응하는 제3 수치를 결정하는 단계는,상기 복수의 매칭 블록 중 i번째 매칭 블록의 템플릿 오차값이 0인 경우, 0보다 큰 기설정된 값을 상기 i번째 매칭 블록에 대응하는 제3 수치로 결정하는 단계; 및상기 i번째 매칭 블록의 템플릿 오차값이 0인 경우, 상기 i번째 매칭 블록의 템플릿 오차값을 상기 i번째 매칭 블록에 대응하는 제3 수치로 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>99. 제97항에 있어서,상기의, 상기 제4 수치 및 상기 각 매칭 블록의 템플릿 오차값을 기반으로, 상기 각 매칭 블록의 가중치를 결정하는 단계는,상기 제4 수치에서 상기 i번째 매칭 블록에 대응하는 제3 수치를 빼서 제5 수치를 얻는 것,상기 제4 수치에 n-1을 곱하여 제6 수치를 얻는 것 - n은 상기 복수의 매칭 블록의 수를 나타냄 -, 및상기 제5 수치 및 상기 제6 수치를 기반으로, 상기 i번째 매칭 블록의 가중치를 결정하는 것을 포함하는 방식에 따라, 상기 복수의 매칭 블록 중 i번째 매칭 블록의 가중치를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>100. 제99항에 있어서,상기의, 상기 제5 수치 및 상기 제6 수치를 기반으로, 상기 i번째 매칭 블록의 가중치를 결정하는 것은,상기 i번째 매칭 블록이 상기 복수의 매칭 블록 중 마지막 매칭 블록이 아닌 경우, 상기 제5 수치와 제6 수치의 비율값을 상기 i번째 매칭 블록의 가중치로 결정하는 단계; 및상기 i번째 매칭 블록이 상기 마지막 매칭 블록인 경우, 기설정된 가중치 총합에서 상기 복수의 매칭 블록 중 상위 n-1개의 매칭 블록의 가중치를 빼서 상기 마지막 매칭 블록의 가중치를 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>101. 제99항에 있어서,상기의, 상기 제5 수치 및 상기 제6 수치를 기반으로, 상기 i번째 매칭 블록의 가중치를 결정하는 것은,상기 제5 수치와 상기 제6 수치의 비율값을 상기 i번째 매칭 블록의 가중치로 결정하는 단계를 포함하되,여기서, 상기 복수의 매칭 블록의 가중치의 합은 기설정된 가중치 총합과 같은 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>102. 제100항 또는 제101항에 있어서,상기 제5 수치와 상기 제6 수치의 비율값은 비트 연산, 덧셈 연산 및 뺄셈 연산을 사용하여 얻은 수치인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>103. 제102항에 있어서,상기 제5 수치 및 상기 제6 수치의 비율값은 아래의 수식에 의해 결정된 수치인 것을 특징으로 하는 방법.Wi=(D5*V*Wsum+DAdd)003e#003e#DShift여기서, *는 곱셈 연산자이고, +는 덧셈 연산자이고, 003e#003e#는 우측 시프트 연산자이고, D5는 상기 제5 수치를 나타내고, Wsum은 상기 가중치 총합을 나타내고, V는 제7 수치를 기반으로 테이블을 조회하여 결정된 수치이고, DShift는 상기 제7 수치를 기반으로 계산하여 결정된 우측 시프트량이고, 상기 제7 수치는 상기 제6 수치를 기반으로 결정된 수치이고, DAdd는 DShift를 기반으로 결정된 수치임.</claim></claimInfo><claimInfo><claim>104. 제103항에 있어서,V 및 DShift는 아래의 방식에 의해 결정되는 것을 특징으로 하는 방법.X=,D7=((n-1)*D4003c#003c#4003e#003e#X)0026#15,V=table[D7]|8,X=D7==0?X:X+1,DShift=X+3,여기서, 는 올림 연산자이고, *는 곱셈 연산자이고, 003c#003c#는 좌측 시프트 연산자이고, 003e#003e#는 우측 시프트 연산자이고, 0026#는 논리 AND 연산자이고, |는 논리 OR 연산자이고, ?는 조건 연산자이고, +는 덧셈 연산자이고, D6은 상기 제6 수치를 나타내고, D4는 상기 제4 수치를 나타내고, table[]은 테이블 조회를 나타내고, D7은 상기 제7 수치를 나타냄.</claim></claimInfo><claimInfo><claim>105. 제103항에 있어서,DAdd=1003c#003c#(DShift-1)이거나，또는 DAdd=1003c#003c#DShift이며,여기서, 003c#003c#는 좌측 시프트 연산자이고, -는 뺄셈 연산자인 것을 특징으로 하는 방법</claim></claimInfo><claimInfo><claim>106. 제95항에 있어서,상기의, 상기 복수의 매칭 블록 중 각 매칭 블록의 가중치를 결정하는 단계는,상기 복수의 매칭 블록의 수를 기반으로, 포함된 가중치가 상기 복수의 매칭 블록의 수와 같은 제1 후보 집합을 복수의 후보 집합 중에서 선택하는 단계 - 상기 복수의 후보 집합 중의 각 후보 집합은 적어도 하나의 후보 가중치를 포함함 - ; 및상기 제1 후보 집합을 기반으로, 상기 각 매칭 블록의 가중치를 결정하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>107. 제106항에 있어서,상기 각 매칭 블록의 템플릿 오차값과 상기 각 매칭 블록의 가중치는 음의 상관 관계가 있는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>108. 제94항에 있어서,상기의, 상기 각 매칭 블록의 가중치를 기반으로 상기 복수의 매칭 블록에 대해 가중 처리를 수행하여 상기 목표 예측 블록을 얻는 단계는,상기 각 매칭 블록에 상기 각 매칭 블록의 가중치를 곱한 후 합산하여 제8 수치를 얻는 단계;상기 제8 수치에 Coffset을 더하여 제9 수치를 얻는 단계; 및상기 제9 수치를 CShift만큼 우측 시프트하여 상기 목표 예측 블록을 얻는 단계를 포함하되,여기서, Coffset은 CShift에 의해 결정된 수치이며, CShift는 상기 복수의 매칭 블록의 가중치의 합에 의해 결정된 수치인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>109. 제108항에 있어서,Coffset=003c#003c#(CShift-1)이고, CShift=이며,여기서, 은 올림 연산자이고, 003c#003c#는 좌측 시프트 연산자이고, Wsum은 상기 복수의 매칭 블록의 가중치의 합을 나타내는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>110. 제94항에 있어서,상기의, 상기 복수의 매칭 블록에 대해 가중 처리를 수행하여 상기 현재 블록의 목표 예측 블록을 얻는 단계는,상기 현재 블록을 복수의 영역으로 분할하는 단계;상기 복수의 영역 중의 제1 영역에 대해, 상기 복수의 매칭 블록 중 각 매칭 블록이 상기 제1 영역에서 가지는 가중치를 결정하는 단계; 및상기 각 매칭 블록이 제1 영역에서 가지는 가중치를 기반으로, 상기 제1 영역에서 상기 복수의 매칭 블록에 대해 가중 처리를 수행하여 상기 목표 예측 블록이 상기 제1 영역에서 가지는 예측값을 얻는 단계를 포함하되,여기서, 상기 목표 예측 블록은 상기 복수의 영역 중 각 영역에서의 예측값을 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>111. 제110항에 있어서,상기의, 상기 현재 블록을 복수의 영역으로 분할하는 단계는,수평 방향 또는 수직 방향으로 상기 현재 블록을 복수의 영역으로 분할하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>112. 제61항 내지 제93항 중 어느 한 항에 있어서,상기의, 상기 적어도 하나의 매칭 블록을 기반으로 상기 현재 블록의 목표 예측 블록을 결정하는 단계는,상기 적어도 하나의 매칭 블록이 단일 매칭 블록인 경우, 제1 인트라 예측 모드를 사용하여 상기 현재 블록을 예측하여 제1 예측 블록을 얻는 단계; 및상기 단일 매칭 블록과 제1 예측 블록에 대해 가중 처리를 수행하여 상기 목표 예측 블록을 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>113. 제112항에 있어서,상기 단일 매칭 블록의 가중치와 상기 제1 예측 블록의 가중치는 모두 미리 정의된 가중치인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>114. 제112항에 있어서,인접 인코딩 블록의 인코딩 정보, 상기 현재 블록의 크기, 상기 현재 블록의 템플릿 크기, 상기 제1 인트라 예측 모드의 유형, 및 상기 현재 블록의 각 영역의 위치 중 적어도 하나를 기반으로, 상기 단일 매칭 블록의 가중치와 상기 제1 예측 블록의 가중치를 결정하는 단계를 더 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>115. 제61항 내지 제93항 중 어느 한 항에 있어서,상기의, 상기 적어도 하나의 매칭 블록을 기반으로 상기 현재 블록의 목표 예측 블록을 결정하는 단계는,상기 적어도 하나의 매칭 블록이 복수의 매칭 블록인 경우, 제2 인트라 예측 모드를 사용하여 상기 현재 블록을 예측하여 제2 예측 블록을 얻는 단계; 및상기 복수의 매칭 블록과 제2 예측 블록에 대해 가중 처리를 수행하여 상기 목표 예측 블록을 얻는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>116. 제115에 있어서,상기 제2 예측 블록의 가중치는 미리 정의된 가중치인 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>117. 제115항에 있어서,인접 인코딩 블록의 인코딩 정보, 상기 현재 블록의 크기, 상기 현재 블록의 템플릿 크기, 상기 제2 인트라 예측 모드의 유형, 상기 복수의 매칭 블록의 가중치 총합, 및 상기 현재 블록의 각 영역의 위치 중 적어도 하나를 기반으로, 상기 제2 예측 블록의 가중치를 결정하는 단계를 더 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>118. 제61항 내지 제117항 중 어느 한 항에 있어서,상기 현재 블록의 템플릿은 좌측 재구성 픽셀, 좌하측 재구성 픽셀, 좌상측 재구성 픽셀, 상측 재구성 픽셀, 우상측 재구성 픽셀 중 적어도 하나를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>119. 제61항 내지 제118항 중 어느 한 항에 있어서,상기의, 인트라 템플릿 매칭 예측(IntraTMP) 모드를 기반으로 상기 현재 블록의 적어도 하나의 매칭 블록을 예측하는 단계는,상기 IntraTMP 모드의 사용 제한 조건을 결정하는 단계; 및상기 제한 조건이 충족되는 경우, 상기 IntraTMP 모드를 기반으로 상기 적어도 하나의 매칭 블록을 예측하는 단계를 포함하는 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>120. 제119항에 있어서,상기 제한 조건은, 현재 블록의 크기, 인접 인코딩 블록의 인코딩 정보, 시퀀스 레벨 플래그 비트, 프레임 레벨 플래그 비트, 매크로블록 레벨 플래그 비트, 상기 현재 블록이 속한 슬라이스의 유형, 상기 현재 블록이 속한 이미지 프레임의 프레임 유형 중 적어도 하나로부터 도출된 것을 특징으로 하는 방법.</claim></claimInfo><claimInfo><claim>121. 디코더로서,잔차 유닛, 예측 유닛, 결정 유닛, 및 재구성 유닛을 포함하되,상기 잔차 유닛은 비트스트림을 기반으로 현재 시퀀스 중 현재 블록의 잔차 블록을 결정하도록 구성되며,상기 예측 유닛은 인트라 템플릿 매칭 예측(IntraTMP) 모드를 기반으로 상기 현재 블록의 적어도 하나의 매칭 블록을 예측하도록 구성되며,상기 결정 유닛은 상기 적어도 하나의 매칭 블록을 기반으로 상기 현재 블록의 목표 예측 블록을 결정하도록 구성되며,상기 재구성 유닛은 상기 현재 블록의 잔차 블록과 상기 목표 예측 블록을 기반으로 상기 현재 블록의 재구성 블록을 얻도록 구성된 것을 특징으로 하는 디코더.</claim></claimInfo><claimInfo><claim>122. 인코더로서,예측 유닛, 결정 유닛, 잔차 유닛, 및 인코딩 유닛을 포함하되,상기 예측 유닛은 인트라 템플릿 매칭 예측(IntraTMP) 모드를 기반으로 현재 시퀀스 중 현재 블록의 적어도 하나의 매칭 블록을 예측하도록 구성되며,상기 결정 유닛은 상기 적어도 하나의 매칭 블록을 기반으로 상기 현재 블록의 목표 예측 블록을 결정하도록 구성되며,상기 잔차 유닛은 상기 목표 예측 블록과 상기 현재 블록의 원본 블록을 기반으로 상기 현재 블록의 잔차 블록을 얻도록 구성되며,상기 인코딩 유닛은 상기 현재 블록의 잔차 블록을 인코딩하도록 구성된 것을 특징으로 하는 인코더.</claim></claimInfo><claimInfo><claim>123. 전자 기기로서,프로세서 및 컴퓨터 판독 가능 저장매체를 포함하되,상기 프로세서는 컴퓨터 프로그램을 실행하도록 구성되며,상기 컴퓨터 판독 가능 저장매체에는 컴퓨터 프로그램이 저장되어 있으며, 상기 컴퓨터 프로그램은 상기 프로세서에 의해 실행될 때, 제1항 내지 제60항 중 어느 한 항에 따른 방법 또는 제61항 내지 제120항 중 어느 한 항에 따른 방법을 구현하는 것을 특징으로 하는 전자 기기.</claim></claimInfo><claimInfo><claim>124. 컴퓨터 판독 가능 저장매체로서,컴퓨터 프로그램을 저장하도록 구성되며, 상기 컴퓨터 프로그램은 컴퓨터가 제1항 내지 제60항 중 어느 한 항에 따른 방법 또는 제61항 내지 제120항 중 어느 한 항에 따른 방법을 실행하도록 하는 것을 특징으로 하는 컴퓨터 판독 가능 저장매체.</claim></claimInfo><claimInfo><claim>125. 컴퓨터 프로그램 제품으로서, 컴퓨터 프로그램/명령을 포함하되,상기 컴퓨터 프로그램/명령은 프로세서에 의해 실행될 때 제1항 내지 제60항 중 어느 한 항에 따른 방법 또는 제61항 내지 제120항 중 어느 한 항에 따른 방법을 구현하는 것을 특징으로 하는 컴퓨터 프로그램 제품.</claim></claimInfo><claimInfo><claim>126. 비트스트림으로서,상기 비트스트림은 제1항 내지 제60항 중 어느 한 항에 따른 방법에서의 비트스트림이거나, 또는 제61항 내지 제120항 중 어느 한 항에 따른 방법에 의해 생성된 비트스트림인 것을 특징으로 하는 비트스트림.</claim></claimInfo></claimInfoArray><applicantInfoArray><applicantInfo><address>중국, 광동 ******, 동관, 창안, 우샤, 하이빈 로드, 넘버 **</address><code>520160675505</code><country>중국</country><engName>GUANGDONG OPPO MOBILE TELECOMMUNICATIONS CORP., LTD.</engName><name>광동 오포 모바일 텔레커뮤니케이션즈 코포레이션 리미티드</name></applicantInfo></applicantInfoArray><inventorInfoArray><inventorInfo><address>중국,...</address><code> </code><country>중국</country><engName>ZHANG, Lai</engName><name>장, 라이</name></inventorInfo><inventorInfo><address>중국,...</address><code> </code><country>중국</country><engName>WANG, Fan</engName><name>왕, 판</name></inventorInfo></inventorInfoArray><agentInfoArray><agentInfo><address>서울 강남구 언주로 **길 **, 대림아크로텔 *층(도곡동)</address><code>920031000651</code><country>대한민국</country><engName>C&amp;amp;S Patent and Law Office</engName><name>특허법인씨엔에스(유)</name></agentInfo></agentInfoArray><priorityInfoArray/><designatedStateInfoArray/><priorArtDocumentsInfoArray/><legalStatusInfoArray><legalStatusInfo><commonCodeName>수리 (Accepted) </commonCodeName><documentEngName>[Patent Application] Document according to the Article 203 of Patent Act</documentEngName><documentName>[특허출원]특허법 제203조에 따른 서면</documentName><receiptDate>2025.07.30</receiptDate><receiptNumber>1-1-2025-0866625-59</receiptNumber></legalStatusInfo><legalStatusInfo><commonCodeName>보정승인간주 (Regarded as an acceptance of amendment) </commonCodeName><documentEngName>[Amendment to Description, etc.] Amendment</documentEngName><documentName>[명세서등 보정]보정서</documentName><receiptDate>2025.08.05</receiptDate><receiptNumber>1-1-2025-0890270-52</receiptNumber></legalStatusInfo><legalStatusInfo><commonCodeName>발송처리완료 (Completion of Transmission) </commonCodeName><documentEngName>Notice of Acceptance</documentEngName><documentName>수리안내서</documentName><receiptDate>2025.08.06</receiptDate><receiptNumber>1-5-2025-0132976-92</receiptNumber></legalStatusInfo></legalStatusInfoArray><imagePathInfo><docName>1020257025599.jpg</docName><largePath>http://plus.kipris.or.kr/kiprisplusws/fileToss.jsp?arg=6c650beb4cee9ce4122b704b88878c932b604cd1321b4c67fdc568263c959855f4ece68e85f5f21b3ec59f1ab5c7cc88a682986a8b7663992ac8d3e3b3be6da7c215f69a698a4414</largePath><path>http://plus.kipris.or.kr/kiprisplusws/fileToss.jsp?arg=ed43a0609e94d6e22d01c5c32ba711cf84c4e3b6f813e5f1530820a2296392095ec2f468e7f6e1fe7d511ddcfe69f0a937728a934813eb23dea7fc05a2111ed5b54e9ebe78be16cd</path></imagePathInfo><rndInfoArray/></item></body><count><numOfRows>1</numOfRows><pageNo>1</pageNo><totalCount>1</totalCount></count></response>