<?xml version="1.0" encoding="UTF-8" standalone="yes"?><response><header><requestMsgID></requestMsgID><responseTime>2025-11-17 18:32:08.328</responseTime><responseMsgID></responseMsgID><successYN>Y</successYN><resultCode>00</resultCode><resultMsg>NORMAL SERVICE.</resultMsg></header><body><item><biblioSummaryInfoArray><biblioSummaryInfo><applicationDate>2021.03.26</applicationDate><applicationFlag> </applicationFlag><applicationNumber>10-2022-7038535</applicationNumber><claimCount>20</claimCount><examinerName> </examinerName><finalDisposal> </finalDisposal><inventionTitle>너츠: 유연한 계위 객체 그래프</inventionTitle><inventionTitleEng>NUTS: FLEXIBLE HIERARCHY OBJECT GRAPHS</inventionTitleEng><openDate>2023.02.14</openDate><openNumber>10-2023-0021642</openNumber><originalApplicationDate> </originalApplicationDate><originalApplicationKind>국제출원/신규</originalApplicationKind><originalApplicationNumber> </originalApplicationNumber><originalExaminationRequestDate>2024.03.05</originalExaminationRequestDate><originalExaminationRequestFlag>Y</originalExaminationRequestFlag><publicationDate> </publicationDate><publicationNumber> </publicationNumber><registerDate> </registerDate><registerNumber> </registerNumber><registerStatus>공개</registerStatus><translationSubmitDate>2022.11.03</translationSubmitDate></biblioSummaryInfo></biblioSummaryInfoArray><ipcInfoArray><ipcInfo><ipcDate>(2006.01.01)</ipcDate><ipcNumber>H04L 9/08</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2013.01.01)</ipcDate><ipcNumber>G06F 21/78</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2006.01.01)</ipcDate><ipcNumber>H04L 9/14</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2019.01.01)</ipcDate><ipcNumber>G06F 16/901</ipcNumber></ipcInfo></ipcInfoArray><familyInfoArray><familyInfo/></familyInfoArray><abstractInfoArray><abstractInfo><astrtCont> 데이터 및 보호된 저장소 유닛을 저장하기 위한 잠금 노드. 잠금 노드는 복수의 키 맵을 제공하는 입력 섹션을 포함하고, 각각은 입력 섹션에 각기 적용된 복수의 1차 키 중 하나에 상응하고, 각각의 키 맵은 적어도 하나의 메인 키를 포함하고, 가변 잠금 섹션은 입력 섹션에 적용된 1차 키에 상응하는 메인 키 상의 논리 연산으로부터 유도 키를 생성하고, 출력 섹션은 유도 키에 응답하여 데이터를 생성한다. </astrtCont></abstractInfo></abstractInfoArray><internationalInfoArray><internationalInfo><internationOpenDate>2021.10.14</internationOpenDate><internationOpenNumber>WO2021206934</internationOpenNumber><internationalApplicationDate>2021.03.26</internationalApplicationDate><internationalApplicationNumber>PCT/US2021/024356</internationalApplicationNumber></internationalInfo></internationalInfoArray><claimInfoArray><claimInfo><claim>1. 적어도 하나의 메모리;상기 적어도 하나의 메모리에 저장된 복수의 잠금 노드(너트(nut)), 상기 잠금 노드의 각각은: 복수의 키 맵을 포함하는 입력 섹션, 상기 키 맵의 각각은 각기 복수의 1차 키 중 상응하는 하나로 암호화되고, 상기 키 맵은 복수의 메인 키를 포함하고; 암호화된 유도 키를 포함하는 가변 잠금 섹션, 상기 암호화된 유도 키는 상기 입력 섹션에 적용된 상기 복수의 1차 키에 상응하는 상기 복수의 메인 키 상의 논리 연산으로부터 유도 키로 복호화되도록 구성되고; 및 암호화된 데이터를 포함하는 출력 섹션을 포함하고, 상기 암호화된 데이터는 상기 유도 키로 복호화되도록 구성되고; 상기 너트의 적어도 하나의 키홀 잠금 노드는 적어도 하나의 접근 속성 키를 포함하는 상기 1차 키의 각각에 대해 키 맵을 포함하고, 상기 적어도 하나의 접근 속성 키는 상기 너트 내에 상응하는 상기 1차 키에 기반해서 역할 기반 접근 제어를 제공하도록 구성되고; 그리고 상기 잠금 노드 중 적어도 하나는 상기 잠금 노드 중 또 다른 하나에 대한 1차 키인 출력 키를 제공하고; 그리고상기 적어도 하나의 메모리에 저장된 적어도 하나의 유연한 계위 객체 그래프(FHOG) 노드를 포함하고, 상기 적어도 하나의 FHOG 노드는: 복수의 FHOG 키 맵을 포함하는 FHOG 입력 섹션, 상기 FHOG 키 맵의 각각은 각기 복수의 1차 FHOG 키 중 상응하는 하나로 암호화되고, 상기 FHOG 키 맵은 복수의 메인 FHOG 키를 포함하고; FHOG 암호화된 유도 키를 포함하는 FHOG 가변 잠금 섹션, 상기 FHOG 암호화된 유도 키는 상기 FHOG 입력 섹션에 적용된 상기 복수의 1차 FHOG 키에 상응하는 상기 복수의 메인 FHOG 키 상의 논리 연산으로부터 유도 키로 복호화되도록 구성되고; 그리고 암호화된 참조 세트를 포함하는 FHOG 출력 섹션을 포함하고, 상기 암호화된 참조 세트는 상기 FHOG 유도 키로 복호화되도록 구성되고, 상기 참조 세트는 상기 너트를 포함하는 참조 기반 파일 시스템을 집합적으로 규정하는 상기 너트의 각각에 대한 참조를 포함하고;각각의 키 맵은 적어도 하나의 접근 속성 키를 포함하고, 상기 입력 섹션은 적어도 하나의 암호화된 접근 역할 키를 더 포함하고, 상기 적어도 하나의 암호화된 접근 역할 키는 상기 적어도 하나의 접근 속성 키에 의해 복호화되도록 구성되고, 상기 적어도 하나의 접근 역할 키는 데이터 상의 적어도 하나의 작동을 가능하게 하도록 구성되고, 상기 적어도 하나의 접근 역할 키는 특정 키 맵을 초래하는 지정된 1차 키와 연관된 허가에 기반하는, 데이터를 구조화하기 위한 시스템. </claim></claimInfo><claimInfo><claim>2. 제 1항에 있어서,디지털 자원에 대한 적어도 하나의 참조는 상기 디지털 자원과 연관된 적어도 하나의 속성을 포함하는, 데이터를 구조화하기 위한 시스템. </claim></claimInfo><claimInfo><claim>3. 제 1항에 있어서,디지털 자원에 대한 적어도 하나의 참조는 또 다른 디지털 자원에 대한 적어도 하나의 참조를 참조하는 적어도 하나의 속성을 포함하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>4. 제 1항에 있어서,상기 잠금 노드 중 하나의 상기 입력 섹션은 상기 잠금 노드의 또 다른 하나에 대한 적어도 하나의 접근 키를 제공하는, 데이터를 구조화하기 위한 시스템. </claim></claimInfo><claimInfo><claim>5. 제 1항에 있어서,상기 잠금 노드 중 하나에 대한 적어도 하나의 키 맵은 적어도 하나의 계층 키를 포함하고, 상기 적어도 하나의 계층 키는 하나의 잠금 노드와는 다른 적어도 하나의 잠금 노드에 대한 다른 키 맵을 복호화하는, 데이터를 구조화하기 위한 시스템. </claim></claimInfo><claimInfo><claim>6. 제 5항에 있어서,상기 너트에 상기 잠금 노드의 상기 적어도 하나의 계층 키 및 상기 입력 섹션은 상기 너트의 어느 잠금 노드가 특정 지정된 1차 키에 대해 접근가능한지를 제어하는, 데이터를 구조화하기 위한 시스템. </claim></claimInfo><claimInfo><claim>7. 제 1항에 있어서,상기 너트의 적어도 하나의 잠금 노드의 상기 출력 섹션은 복수의 다른 어플리케이션을 가로질러 상기 너트의 접근에 관련된 데이터를 저장하는 적어도 하나의 로그 섹션을 저장하는, 데이터를 구조화하기 위한 시스템. </claim></claimInfo><claimInfo><claim>8. 제 1항에 있어서,상기 데이터 상에 허용된 모든 규정된 작동의 연합을 형성하도록 다른 제공된 적어도 하나의 접근 역할 키와 논리 연산에서 상기 적어도 하나의 접근 역할 키를 조합하는 것을 더 포함하는, 데이터를 구조화하기 위한 시스템. </claim></claimInfo><claimInfo><claim>9. 제 7항에 있어서,상기 적어도 하나의 로그 섹션은 암호화된 형태로 저장되는, 데이터를 구조화하기 위한 시스템. </claim></claimInfo><claimInfo><claim>10. 제 7항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 로그된 것과 로그되지 않은 것을 제어하는, 데이터를 구조화하기 위한 시스템. </claim></claimInfo><claimInfo><claim>11. 제 7항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 적어도 하나의 로그에 세부의 레벨을 제어하는, 데이터를 구조화하기 위한 시스템. </claim></claimInfo><claimInfo><claim>12. 제 7항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 생성하는 로그의 유형을 제어하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>13. 제 12항에 있어서,상기 로그의 유형은 상기 너트를 수반하는 처리 이벤트를 수반하는 로그 엔트리를 포함하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>14. 제 12항에 있어서,상기 로그의 유형은 상기 너트에 상기 잠금 노드 중 적어도 하나에서 상기 데이터를 수반하는 이력 검토 엔트리를 포함하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>15. 제 7항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 로그 엔트리를 생성하는 방법을 제어하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>16. 제 1항에 있어서,상기 참조 세트는 너트 식별자의 목록을 포함하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>17. 제 1항에 있어서,상기 참조 세트는 너트 페이로드 유형의 목록을 포함하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>18. 제 1항에 있어서,상기 파일 시스템은 상기 너트의 물리적 위치와 독립적으로 규정되는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>19. 제 1항에 있어서,상기 1차 FHOG 키와 연관된 허가는 각각의 참조된 너트의 상기 1차 키와 연관된 상기 허가로부터 독립적인, 데이터를 구조화하기 위한 시스템. </claim></claimInfo><claimInfo><claim>20. 제 1항에 있어서,상기 FHOG 출력 섹션은 상기 FHOG 유도 키로 복호화하도록 구성된 다른 암호화된 데이터를 더 포함하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>21. 적어도 하나의 프로세서에 의해, 적어도 하나의 메모리에서 데이터 저장 구조에 접근하는 단계, 상기 데이터 저장 구조는 적어도 하나의 다른 데이터 저장 구조를 생성하도록 상기 데이터 저장 구조에서 특정된 시퀀스에서 수행될 복수의 구성 명령어를 포함하는 적어도 하나의 명령어 필드를 포함하고;상기 적어도 하나의 프로세서에 의해, 상기 특정된 시퀀스에서 복수의 구성 명령어를 실행하는 단계; 및상기 적어도 하나의 프로세서에 의해, 상기 실행에 의해 생성된 상기 적어도 하나의 다른 데이터 저장 구조를 저장하거나 그에 접근하는 단계를 포함하고,상기 적어도 하나의 명령어 필드에 포함된 상기 복수의 구성 명령어 내의 적어도 하나의 구성 명령어의 상기 실행은 상기 적어도 하나의 다른 데이터 저장 구조 내에 그리고 그에 의해 완전히 작동가능한 적어도 하나의 암호 접근 제어층을 구성하는, 데이터 저장 구조를 구성하기 위한 방법.  </claim></claimInfo><claimInfo><claim>22. 제 21항에 있어서,상기 적어도 하나의 프로세서에 의해, 상기 적어도 하나의 다른 데이터 저장 구조의 적어도 하나의 명령어 필드에 상기 적어도 하나의 명령어 필드를 복사하는 단계를 더 포함하는, 데이터 저장 구조를 구성하기 위한 방법. </claim></claimInfo><claimInfo><claim>23. 제 21항에 있어서,상기 접근은 적어도 하나의 다른 데이터 저장 구조를 생성하도록 라이브러리에 특정된 시퀀스에서 수행될 복수의 구성 명령어의 상기 라이브러리로부터 상기 적어도 하나의 명령어 필드에 상기 복수의 구성 명령어를 가져오는 단계를 포함하는, 데이터 저장 구조를 구성하기 위한 방법. </claim></claimInfo><claimInfo><claim>24. 제 21항에 있어서,상기 적어도 하나의 암호 접근 제어층은 적어도 하나의 암호 가변 잠금층을 포함하는, 데이터 저장 구조를 구성하기 위한 방법. </claim></claimInfo><claimInfo><claim>25. 제 21항에 있어서,상기 적어도 하나의 암호 접근 제어층은 적어도 하나의 암호 계층 접근 제어층을 포함하는, 데이터 저장 구조를 구성하기 위한 방법.</claim></claimInfo><claimInfo><claim>26. 제 21항에 있어서,상기 적어도 하나의 암호 접근 제어층은 적어도 하나의 암호 역할 기반 접근 제어층을 포함하는, 데이터 저장 구조를 구성하기 위한 방법.</claim></claimInfo><claimInfo><claim>27. 제 21항에 있어서,상기 데이터 저장 구조는:상기 적어도 하나의 메모리에 저장된 복수의 잠금 노드(너트)를 포함하고, 상기 잠금 노드의 각각은:복수의 키 맵을 포함하는 입력 섹션, 상기 키 맵의 각각은 각기 복수의 1차 키 중 상응하는 하나로 암호화되고, 상기 키 맵은 복수의 메인 키를 포함하고; 암호화된 유도 키를 포함하는 가변 잠금 섹션, 상기 암호화된 유도 키는 상기 입력 섹션에 적용된 상기 복수의 1차 키에 상응하는 상기 복수의 메인 키 상의 논리 연산으로부터 유도 키로 복호화되도록 구성되고; 그리고 암호화된 데이터를 포함하는 출력 섹션을 포함하고, 상기 암호화된 데이터는 상기 유도 키로 복호화되도록 구성되고;상기 너트의 적어도 하나의 키홀 잠금 노드는 적어도 하나의 접근 속성 키를 포함하는 상기 1차 키의 각각에 대해 키 맵을 포함하고, 상기 적어도 하나의 접근 속성 키는 상기 너트 내에 상응하는 상기 1차 키에 기반해서 역할 기반 접근 제어를 제공하도록 구성되고; 그리고상기 잠금 노드 중 적어도 하나는 상기 잠금 노드 중 또 다른 하나에 대한 1차 키인 출력 키를 제공하고;각각의 키 맵은 적어도 하나의 접근 속성 키를 포함하고, 상기 입력 섹션은 적어도 하나의 암호화된 접근 역할 키를 더 포함하고, 상기 적어도 하나의 암호화된 접근 역할 키는 상기 적어도 하나의 접근 속성 키에 의해 복호화되도록 구성되고, 상기 적어도 하나의 접근 역할 키는 데이터 상의 적어도 하나의 작동을 가능하게 하도록 구성되고, 상기 적어도 하나의 접근 역할 키는 특정 키 맵을 초래하는 지정된 1차 키와 연관된 허가에 기반하는, 데이터 저장 구조를 구성하기 위한 방법.</claim></claimInfo><claimInfo><claim>28. 제 27항에 있어서,상기 잠금 노드 중 하나의 상기 입력 섹션에 의해, 상기 잠금 노드의 또 다른 하나에 대한 적어도 하나의 접근 키를 제공하는 단계를 더 포함하는, 데이터 저장 구조를 구성하기 위한 방법.</claim></claimInfo><claimInfo><claim>29. 제 27항에 있어서,상기 잠금 노드 중 하나에 대한 적어도 하나의 키 맵은 적어도 하나의 계층 키를 포함하고, 상기 적어도 하나의 계층 키는 하나의 잠금 노드와는 다른 적어도 하나의 잠금 노드에 대한 다른 키 맵을 복호화하는, 데이터 저장 구조를 구성하기 위한 방법.</claim></claimInfo><claimInfo><claim>30. 제 29항에 있어서,상기 너트에 상기 잠금 노드의 상기 적어도 하나의 계층 키 및 상기 입력 섹션에 의해, 상기 너트 내의 어느 잠금 노드가 특정 지정된 1차 키에 대해 접근가능한지를 제어하는 단계를 더 포함하는, 데이터 저장 구조를 구성하기 위한 방법.</claim></claimInfo><claimInfo><claim>31. 제 27항에 있어서,상기 너트의 적어도 하나의 잠금 노드의 상기 출력 섹션에서, 복수의 다른 어플리케이션을 가로질러 상기 너트의 접근에 관련된 데이터를 저장하는 적어도 하나의 로그 섹션을 저장하는 단계를 더 포함하는, 데이터 저장 구조를 구성하기 위한 방법.</claim></claimInfo><claimInfo><claim>32. 제 27항에 있어서,데이터 상에 허용된 모든 규정된 작동의 연합을 형성하도록 다른 제공된 적어도 하나의 접근 역할 키와 논리 연산에서 상기 적어도 하나의 접근 역할 키를 조합하는 단계를 더 포함하는, 데이터 저장 구조를 구성하기 위한 방법.</claim></claimInfo><claimInfo><claim>33. 제 31항에 있어서,적어도 하나의 로그는 암호화된 형태로 저장되는, 데이터 저장 구조를 구성하기 위한 방법.</claim></claimInfo><claimInfo><claim>34. 제 31항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 로그된 것과 로그되지 않은 것을 제어하는, 데이터 저장 구조를 구성하기 위한 방법.</claim></claimInfo><claimInfo><claim>35. 제 31항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 적어도 하나의 로그에 세부의 레벨을 제어하는, 데이터 저장 구조를 구성하기 위한 방법.</claim></claimInfo><claimInfo><claim>36. 제 31항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 생성하는 로그의 유형을 제어하는, 데이터 저장 구조를 구성하기 위한 방법.</claim></claimInfo><claimInfo><claim>37. 제 36항에 있어서,상기 로그의 유형은 상기 너트를 수반하는 처리 이벤트를 수반하는 로그 엔트리를 포함하는, 데이터 저장 구조를 구성하기 위한 방법.</claim></claimInfo><claimInfo><claim>38. 제 36항에 있어서,상기 로그의 유형은 상기 너트에서 상기 데이터를 수반하는 이력 검토 엔트리를 포함하는, 데이터 저장 구조를 구성하기 위한 방법.</claim></claimInfo><claimInfo><claim>39. 제 31항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 로그 엔트리를 생성하는 방법을 제어하는, 데이터 저장 구조를 구성하기 위한 방법.</claim></claimInfo><claimInfo><claim>40. 제 21항에 있어서,생성될 때, 상기 적어도 하나의 다른 데이터 저장 구조는:적어도 하나의 메모리에 저장된 복수의 잠금 노드 (너트)를 포함하고, 상기 잠금 노드의 각각은: 복수의 키 맵을 포함하는 입력 섹션, 상기 키 맵의 각각은 각기 복수의 1차 키 중 상응하는 하나로 암호화되고, 상기 키 맵은 복수의 메인 키를 포함하고; 암호화된 유도 키를 포함하는 가변 잠금 섹션, 상기 암호화된 유도 키는 상기 입력 섹션에 적용된 상기 복수의 1차 키에 상응하는 상기 복수의 메인 키 상의 논리 연산으로부터 유도 키로 복호화되도록 구성되고; 그리고 암호화된 데이터를 포함하는 출력 섹션을 포함하고, 상기 암호화된 데이터는 상기 유도 키로 복호화되도록 구성되고;상기 너트의 적어도 하나의 키홀 잠금 노드는 적어도 하나의 접근 속성 키를 포함하는 1차 키의 각각에 대해 키 맵을 포함하고, 적어도 하나의 접근 속성 키는 너트 내에 상응하는 1차 키에 기반해서 역할 기반 접근 제어를 제공하도록 구성되고; 그리고상기 잠금 노드 중 적어도 하나는 상기 잠금 노드 중 또 다른 하나에 대한 1차 키인 출력 키를 제공하고;각각의 키 맵은 적어도 하나의 접근 속성 키를 포함하고, 상기 입력 섹션은 적어도 하나의 암호화된 접근 역할 키를 더 포함하고, 상기 적어도 하나의 암호화된 접근 역할 키는 상기 적어도 하나의 접근 속성 키에 의해 복호화되도록 구성되고, 상기 적어도 하나의 접근 역할 키는 데이터 상의 적어도 하나의 작동을 가능하게 하도록 구성되고, 상기 적어도 하나의 접근 역할 키는 특정 키 맵을 초래하는 지정된 1차 키와 연관된 허가에 기반하는, 데이터 저장 구조를 구성하기 위한 방법.</claim></claimInfo><claimInfo><claim>41. 적어도 하나의 메모리; 적어도 하나의 페이로드 섹션; 및, 페이로드와는 다른 적어도 하나의 카르나크 섹션;을 포함하는 상기 적어도 하나의 메모리에 저장된 데이터 저장 구조;를 포함하고, 각각의 카르나크 섹션은 적어도 하나의 카르나크 검토를 포함하고, 각각의 카르나크 검토는:  데이터 구조의 적어도 하나의 섹션의 과거 검토,  상기 데이터 저장 구조의 과거 이벤트 로그,  상기 카르나크 섹션에 대한 관심의 이벤트의 과거 이벤트 로그, 및   적어도 하나의 이벤트가 트리거될 때 처리하도록 구성된 적어도 하나의 명령어를 포함하는 가능한 미래 이벤트 중 적어도 하나이고, 상기 적어도 하나의 명령어를 처리하는 결론은 적어도 하나의 구성가능한 이벤트를 일으키는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>42. 제 41항에 있어서,적어도 하나의 가능한 미래 이벤트는:상기 데이터 저장 구조;상기 시스템에 접근가능한 또 다른 데이터 저장 구조;상기 적어도 하나의 명령어의 상기 처리로부터 분리된 프로세스;상기 적어도 하나의 페이로드 섹션;상기 적어도 하나의 카르나크 섹션; 및상기 시스템의 작동 시스템 중 적어도 하나 상에 작동하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>43. 제 41항에 있어서,적어도 하나의 가능한 미래 이벤트는:상기 시스템의 외부에 생성된 적어도 하나의 이벤트;상기 시스템의 내부에 생성된 적어도 하나의 이벤트; 및시간의 기간의 지남에 의해 생성된 적어도 하나의 이벤트 중 적어도 하나에 응답하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>44. 제 41항에 있어서,상기 적어도 하나의 구성가능한 이벤트는:상기 시스템에 대한 내부 이벤트; 및상기 시스템에 대한 외부 이벤트 중 적어도 하나이고;상기 적어도 하나의 명령어를 처리하는 결론은: 반환값 없음; 반환값; 상기 적어도 하나의 명령어의 성공적인 처리에 상응하는 반환값; 및 상기 적어도 하나의 명령어의 성공적이지 않은 처리에 상응하는 반환값 중 적어도 하나를 반환하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>45. 제 41항에 있어서,상기 데이터 저장 구조는:상기 적어도 하나의 메모리에 저장된 복수의 잠금 노드(너트)를 포함하고, 상기 잠금 노드의 각각은: 복수의 키 맵을 포함하는 입력 섹션, 상기 키 맵의 각각은 각기 복수의 1차 키 중 상응하는 하나로 암호화되고, 상기 키 맵은 복수의 메인 키를 포함하고; 암호화된 유도 키를 포함하는 가변 잠금 섹션, 상기 암호화된 유도 키는 상기 입력 섹션에 적용된 상기 복수의 1차 키에 상응하는 상기 복수의 메인 키 상의 논리 연산으로부터 유도 키로 복호화되도록 구성되고; 및 암호화된 데이터를 포함하는 출력 섹션을 포함하고, 상기 암호화된 데이터는 상기 유도 키로 복호화되도록 구성되고;상기 너트의 적어도 하나의 키홀 잠금 노드는 적어도 하나의 접근 속성 키를 포함하는 1차 키의 각각에 대해 키 맵을 포함하고, 적어도 하나의 접근 속성 키는 너트 내에 상응하는 1차 키에 기반해서 역할 기반 접근 제어를 제공하도록 구성되고; 그리고상기 잠금 노드 중 적어도 하나는 상기 잠금 노드 중 또 다른 하나에 대한 1차 키인 출력 키를 제공하고;각각의 키 맵은 적어도 하나의 접근 속성 키를 포함하고, 상기 입력 섹션은 적어도 하나의 암호화된 접근 역할 키를 더 포함하고, 상기 적어도 하나의 암호화된 접근 역할 키는 상기 적어도 하나의 접근 속성 키에 의해 복호화되도록 구성되고, 상기 적어도 하나의 접근 역할 키는 데이터 상의 적어도 하나의 작동을 가능하게 하도록 구성되고, 상기 적어도 하나의 접근 역할 키는 특정 키 맵을 초래하는 지정된 1차 키와 연관된 허가에 기반하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>46. 제 45항에 있어서,상기 잠금 노드 중 하나의 상기 입력 섹션은 잠금 노드의 또 다른 하나에 대한 적어도 하나의 접근 키를 제공하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>47. 제 45항에 있어서,상기 잠금 노드 중 하나에 대한 적어도 하나의 키 맵은 적어도 하나의 계층 키를 포함하고, 상기 적어도 하나의 계층 키는 하나의 잠금 노드와는 다른 적어도 하나의 잠금 노드에 대한 다른 키 맵을 복호화하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>48. 제 47항에 있어서,상기 너트에 상기 잠금 노드의 상기 적어도 하나의 계층 키 및 상기 입력 섹션은 상기 너트 내의 어느 잠금 노드가 특정 지정된 1차 키에 대해 접근가능한지를 제어하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>49. 제 45항에 있어서,복수의 다른 어플리케이션을 가로질러 상기 너트의 접근에 관련된 데이터를 저장하는 적어도 하나의 카르나크 섹션은 상기 너트의 적어도 하나의 잠금 노드의 상기 출력 섹션에 저장되는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>50. 제 45항에 있어서,상기 적어도 하나의 접근 역할 키는 상기 데이터 상에 허용된 모든 규정된 작동의 연합을 형성하도록 다른 제공된 적어도 하나의 접근 역할 키와 논리 연산에서 조합되는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>51. 제 49항에 있어서,상기 적어도 하나의 카르나크 섹션은 암호화된 형태로 저장되는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>52. 제 49항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 상기 적어도 하나의 카르나크 섹션에서 로그된 것과 로그되지 않은 것을 제어하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>53. 제 49항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 상기 적어도 하나의 카르나크 검토에 세부의 레벨을 제어하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>54. 제 49항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 생성하는 카르나크 검토의 유형을 제어하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>55. 제 54항에 있어서,상기 카르나크 검토의 유형은:상기 너트를 수반하는 처리 이벤트를 수반하는 로그 엔트리;상기 너트에서 상기 데이터를 수반하는 과거 검토 엔트리;상기 너트 상에 작동하는 가능한 미래 이벤트 엔트리;처리 시스템에 접근가능한 또 다른 데이터 저장 구조 상에 작동하는 가능한 미래 이벤트 엔트리;상기 적어도 하나의 명령어의 상기 처리로부터 분리된 프로세스 상에 작동하는 가능한 미래 이벤트 엔트리;상기 시스템의 작동 시스템 상에 작동하는 가능한 미래 이벤트 엔트리;상기 시스템의 외부에 생성된 적어도 하나의 이벤트에 응답하는 가능한 미래 이벤트 엔트리;상기 시스템의 내부에 생성된 적어도 하나의 이벤트에 응답하는 가능한 미래 이벤트 엔트리; 및시간의 기간의 지남에 의해 생성된 적어도 하나의 이벤트에 응답하는 가능한 미래 이벤트 엔트리 중 적어도 하나를 포함하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>56. 제 49항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 카르나크 검토를 생성하는 방법을 제어하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>57. 적어도 하나의 프로세서에 의해, 각각의 그룹 멤버에 적어도 하나의 상응하는 키를 분배하는 적어도 하나의 그룹 관리자 및 적어도 하나의 관리자 키에 의해 그룹 멤버의 사각형 크로스 매트릭스를 생성하는 단계, 상기 사각형 크로스 매트릭스는 각기 각각의 행 멤버 및 각각의 열 멤버를 갖는 복수의 요소를 포함하고;상기 적어도 하나의 프로세서에 의해, 키의 조합과 각각의 사각형 크로스 매트릭스 요소를 채우는 단계, 상기 채우는 단계는: 어디에서 상기 행 멤버와 상기 열 멤버가 동일한지를 포함하는 상기 행 멤버 및 상기 열 멤버 사이의 암호화된 양방향 데이터 흐름을 위해 사용되는 적어도 하나의 키를 생성하는 단계; 상기 열 멤버로부터 상기 행 멤버로 암호화된 양방향 데이터 흐름을 위해 사용되는 적어도 하나의 키를 생성하는 단계; 및 상기 행 멤버로부터 상기 열 멤버로 암호화된 양방향 데이터 흐름을 위해 사용된 적어도 하나의 키 부분을 복사하고 위치시키는 단계; 중 적어도 하나를 포함하고,상기 적어도 하나의 프로세서에 의해, 상기 사각형 크로스 매트릭스의 적어도 하나의 선택 크로스 매트릭스 요소로부터 적어도 하나의 선택 키를 제거하고, 그로써 상기 적어도 하나의 선택 크로스 매트릭스 요소에 상응하는 그룹 멤버의 쌍 사이에 적어도 하나의 선택 방향에서 암호화된 데이터 흐름을 제한하는 단계;상기 적어도 하나의 프로세서에 의해, 각각의 행에 상응하는 각각의 그룹 멤버에 대해 상기 적어도 하나의 상응하는 키로 복호화되도록 크로스 매트릭스 요소의 각각의 행을 구성하는 단계;상기 적어도 하나의 프로세서에 의해, 적어도 하나의 관리자 키에 의해 복호화되도록 각각의 그룹 멤버에 대해 각각의 적어도 하나의 상응하는 키의 사본을 구성하는 단계; 및상기 적어도 하나의 프로세서에 의해, 상기 적어도 하나의 그룹 관리자에 의해 복호화되도록 상기 적어도 하나의 관리자 키를 구성하는 단계;를 포함하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법.</claim></claimInfo><claimInfo><claim>58. 제 57항에 있어서,상기 적어도 하나의 그룹 관리자는 적어도 하나의 그룹 멤버를 포함하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법.</claim></claimInfo><claimInfo><claim>59. 제 57항에 있어서,상기 분배는: 상기 그룹 멤버 중 적어도 하나에 대해 상기 적어도 하나의 상응하는 키를 생성하는 단계; 및 상기 적어도 하나의 관리자 키를 생성하는 단계 중 적어도 하나를 더 포함하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>60. 제 57항에 있어서,상기 적어도 하나의 프로세서에 의해, 적어도 하나의 그룹 멤버의 상기 적어도 하나의 상응하는 키로 상기 적어도 하나의 관리자 키의 사본을 암호화함으로써 상기 적어도 하나의 그룹 관리자와는 다른 상기 그룹 멤버로부터 적어도 하나의 제 2 그룹 관리자를 할당하는 단계를 더 포함하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>61. 제 57항에 있어서,상기 적어도 하나의 프로세서에 의해, 상기 적어도 하나의 관리자 키를 사용하여 상기 적어도 하나의 그룹 관리자에 의해 상기 그룹에 신규 멤버를 추가하는 단계를 더 포함하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>62. 제 57항에 있어서,상기 적어도 하나의 프로세서에 의해, 상기 그룹 멤버의 상기 적어도 하나의 상응하는 키로 복호화되도록 구성된 각각의 그룹 멤버 키에 분배하는 단계를 더 포함하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>63. 제 57항에 있어서,상기 적어도 하나의 프로세서에 의해, 각각의 그룹 멤버 및 상기 적어도 하나의 그룹 관리자에 대해 입력된 데이터 저장 구조에 모든 키를 저장하는 단계를 더 포함하고, 상기 데이터 저장 구조는:적어도 하나의 메모리에 저장된 복수의 잠금 노드(너트)를 포함하고, 상기 잠금 노드의 각각은:복수의 키 맵을 포함하는 입력 섹션, 키 맵의 각각은 각기 복수의 1차 키 중 상응하는 하나로 암호화되고, 키 맵은 복수의 메인 키를 포함하고;암호화된 유도 키를 포함하는 가변 잠금 섹션, 상기 암호화된 유도 키는 상기 입력 섹션에 적용된 상기 복수의 1차 키에 상응하는 상기 복수의 메인 키 상의 논리 연산으로부터 유도 키로 복호화되도록 구성되고; 및암호화된 데이터를 포함하는 출력 섹션을 포함하고, 상기 암호화된 데이터는 상기 유도 키로 복호화되도록 구성되고;상기 너트의 적어도 하나의 키홀 잠금 노드는 적어도 하나의 접근 속성 키를 포함하는 상기 1차 키의 각각에 대해 키 맵을 포함하고, 상기 적어도 하나의 접근 속성 키는 상기 너트 내에 상응하는 상기 1차 키에 기반해서 역할 기반 접근 제어를 제공하도록 구성되고; 그리고 상기 잠금 노드 중 적어도 하나는 상기 잠금 노드 중 또 다른 하나에 대한 1차 키인 출력 키를 제공하고;각각의 키 맵은 적어도 하나의 접근 속성 키를 포함하고, 상기 입력 섹션은 적어도 하나의 암호화된 접근 역할 키를 더 포함하고, 상기 적어도 하나의 암호화된 접근 역할 키는 상기 적어도 하나의 접근 속성 키에 의해 복호화되도록 구성되고, 상기 적어도 하나의 접근 역할 키는 데이터 상의 적어도 하나의 작동을 가능하게 하도록 구성되고, 상기 적어도 하나의 접근 역할 키는 특정 키 맵을 초래하는 지정된 1차 키와 연관된 허가에 기반하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>64. 제 63항에 있어서,잠금 노드 중 하나의 입력 섹션에 의해, 잠금 노드의 또 다른 하나에 대한 적어도 하나의 접근 키를 제공하는 단계를 더 포함하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>65. 제 63항에 있어서,상기 잠금 노드 중 하나에 대한 적어도 하나의 키 맵은 적어도 하나의 계층 키를 포함하고, 상기 적어도 하나의 계층 키는 하나의 잠금 노드와는 다른 적어도 하나의 잠금 노드에 대한 다른 키 맵을 복호화하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>66. 제 65항에 있어서,적어도 하나의 계층 키 및 너트에 잠금 노드의 입력 섹션에 의해, 너트 내의 어느 잠금 노드가 특정 지정된 1차 키에 대해 접근가능한지를 제어하는 단계를 더 포함하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>67. 제 63항에 있어서,상기 너트의 적어도 하나의 잠금 노드의 상기 출력 섹션에서, 복수의 다른 어플리케이션을 가로질러 상기 너트의 접근에 관련된 데이터를 저장하는 적어도 하나의 카르나크 섹션을 저장하는 단계를 더 포함하고, 상기 적어도 하나의 카르나크 섹션은:적어도 하나의 카르나크 검토를 포함하고, 각각의 카르나크 검토는:상기 너트의 적어도 하나의 섹션의 과거 검토,상기 너트의 과거 이벤트 로그,상기 카르나크 섹션에 대한 관심의 이벤트의 과거 이벤트 로그, 및적어도 하나의 이벤트가 트리거될 때 처리하도록 구성된 적어도 하나의 명령어를 포함하는 가능한 미래 이벤트 중 적어도 하나이고, 상기 적어도 하나의 명령어를 처리하는 결론은 적어도 하나의 구성가능한 이벤트를 일으키는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>68. 제 67항에 있어서,적어도 하나의 가능한 미래 이벤트는:상기 너트;상기 시스템에 접근가능한 또 다른 데이터 저장 구조;상기 적어도 하나의 명령어의 상기 처리로부터 분리된 프로세스;적어도 하나의 페이로드 섹션;적어도 하나의 카르나크 섹션; 및상기 시스템의 작동 시스템 중 적어도 하나 상에 작동하는, 데이터를 구조화하기 위한 시스템.</claim></claimInfo><claimInfo><claim>69. 제 67항에 있어서,적어도 하나의 가능한 미래 이벤트는:시스템의 외부에 생성된 적어도 하나의 이벤트;상기 시스템의 내부에 생성된 적어도 하나의 이벤트; 및시간의 기간의 지남에 의해 생성된 적어도 하나의 이벤트 중 적어도 하나에 응답하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>70. 제 63항에 있어서,데이터 상에 허용된 모든 규정된 작동의 연합을 형성하도록 다른 제공된 적어도 하나의 접근 역할 키와 논리 연산에서 상기 적어도 하나의 접근 역할 키를 조합하는 단계를 더 포함하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>71. 제 67항에 있어서,상기 적어도 하나의 카르나크 섹션은 암호화된 형태로 저장되는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>72. 제 67항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 상기 적어도 하나의 카르나크 섹션에서 로그된 것과 로그되지 않은 것을 제어하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>73. 제 67항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 상기 적어도 하나의 카르나크 검토에 세부의 레벨을 제어하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>74. 제 67항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 생성하는 카르나크 검토의 유형을 제어하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>75. 제 74항에 있어서,상기 카르나크 검토의 유형은:상기 너트를 수반하는 처리 이벤트를 수반하는 로그 엔트리;상기 너트에서 상기 데이터를 수반하는 과거 검토 엔트리;상기 너트 상에 작동하는 가능한 미래 이벤트 엔트리;처리 시스템에 접근가능한 또 다른 데이터 저장 구조 상에 작동하는 가능한 미래 이벤트 엔트리;상기 적어도 하나의 명령어의 상기 처리로부터 분리된 프로세스 상에 작동하는 가능한 미래 이벤트 엔트리;상기 시스템의 작동 시스템 상에 작동하는 가능한 미래 이벤트 엔트리;상기 시스템의 외부에 생성된 적어도 하나의 이벤트에 응답하는 가능한 미래 이벤트 엔트리;상기 시스템의 내부에 생성된 적어도 하나의 이벤트에 응답하는 가능한 미래 이벤트 엔트리; 및시간의 기간의 지남에 의해 생성된 적어도 하나의 이벤트에 응답하는 가능한 미래 이벤트 엔트리 중 적어도 하나를 포함하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>76. 제 67항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 카르나크 검토를 생성하는 방법을 제어하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법. </claim></claimInfo><claimInfo><claim>77. 제 63항에 있어서,상기 적어도 하나의 프로세서에 의해, 상기 그룹 멤버의 상기 적어도 하나의 상응하는 키로 복호화되도록 구성된 각각의 그룹 멤버 너트에 분배하는 단계를 더 포함하는, 그룹에서 데이터 흐름을 암호로 제어하는 방법.</claim></claimInfo><claimInfo><claim>78. 처리 그룹 멤버 대신에 제 1 시스템에 메모리에 적어도 하나의 프로세서에 의해, 상기 제 1 시스템을 포함하는 적어도 하나의 제 2 시스템으로부터, 적어도 하나의 그룹 객체의 적어도 하나의 그룹 식별자를 참조하는 적어도 하나의 카탈로그 객체를 수신하는 단계, 상기 그룹 객체는: 적어도 하나의 그룹 식별자, 및 상기 처리 그룹 멤버를 포함하는 적어도 하나의 멤버를 포함하고,상기 적어도 하나의 카탈로그 객체는: 적어도 하나의 카탈로그 식별자, 및 적어도 하나의 그룹 식별자, 및 적어도 하나의 그룹의 상기 적어도 하나의 멤버와 적어도 하나의 공유된 데이터 객체에 대한 적어도 하나의 참조를 포함하고, 그리고상기 적어도 하나의 공유된 데이터 객체는: 적어도 하나의 데이터 객체 식별자, 적어도 하나의 페이로드, 검토의 이력, 적어도 하나의 버전 마커, 및 병합 방법을 나타내는 적어도 하나의 속성을 포함하고;상기 적어도 하나의 프로세서에 의해, 로컬 카탈로그 객체에서 발견되지 않은 공유된 데이터 객체 식별자의 목록을 생성하는 동일한 적어도 하나의 카탈로그 식별자, 및 적어도 하나의 그룹 식별자를 갖는 적어도 하나의 로컬 카탈로그 객체와 수신된 적어도 하나의 카탈로그 객체를 비교하는 단계; 상기 적어도 하나의 프로세서에 의해, 상기 제 1 시스템을 포함하는 상기 적어도 하나의 제 2 시스템으로부터 상기 공유된 데이터 객체 식별자의 목록에 상기 적어도 하나의 공유된 데이터 객체를 수신하는 단계;상기 적어도 하나의 프로세서에 의해, 동일한 적어도 하나의 데이터 객체 식별자를 갖는 로컬 데이터 객체와 수신된 적어도 하나의 공유된 데이터 객체를 동기화하고, 상기 적어도 하나의 데이터 객체 식별자의 버전을 갖는 동기화된 데이터 객체를 생성하고 상기 동기화된 데이터 객체를 국부적으로 저장하는 단계; 및상기 적어도 하나의 프로세서에 의해, 상기 동기화된 데이터 객체의 상기 적어도 하나의 데이터 객체 식별자의 상기 버전을 참조하는 상기 적어도 하나의 로컬 카탈로그 객체에 적어도 하나의 카탈로그 엔트리를 업데이트하는 단계를 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>79. 제 78항에 있어서,상기 적어도 하나의 공유된 데이터 객체에 대한 상기 적어도 하나의 참조는 상기 적어도 하나의 공유된 데이터 객체의 적어도 하나의 버전 마커를 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>80. 제 78항에 있어서,상기 로컬 데이터 객체는 상기 제 1 시스템에 대해 적어도 하나의 국부적으로 접근가능한 영구 저장소에 위치되는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>81. 제 78항에 있어서,상기 로컬 데이터 객체는 상기 제 1 시스템의 적어도 하나의 메모리에 위치되는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>82. 제 78항에 있어서,상기 적어도 하나의 로컬 카탈로그 객체는 상기 제 1 시스템을 포함하는 상기 적어도 하나의 제 2 시스템의 적어도 하나의 국부적으로 접근가능한 영구 저장소에 위치되는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>83. 제 78항에 있어서,상기 적어도 하나의 로컬 카탈로그 객체는 상기 제 1 시스템을 포함하는 상기 적어도 하나의 제 2 시스템의 적어도 하나의 메모리에 위치되는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>84. 제 78항에 있어서,상기 적어도 하나의 로컬 카탈로그 객체는 상기 수신된 적어도 하나의 카탈로그 객체에 의해 대체되는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>85. 제 78항에 있어서,적어도 하나의 로컬 카탈로그는 카탈로그로서 작동하는 적어도 하나의 맵 객체를 참조하고; 그리고 상기 적어도 하나의 맵 객체는:적어도 하나의 맵 식별자,적어도 하나의 그룹 식별자, 및상기 적어도 하나의 그룹의 상기 적어도 하나의 멤버와 적어도 하나의 공유된 데이터 객체에 대한 적어도 하나의 참조를 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>86. 제 85항에 있어서,상기 적어도 하나의 프로세서에 의해, 상기 동기화된 데이터 객체의 상기 적어도 하나의 데이터 객체 식별자의 상기 버전을 참조하는 카탈로그로서 작동하는 적어도 하나의 로컬 맵 객체에 적어도 하나의 맵 엔트리를 업데이트하는 단계를 더 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>87. 제 78항에 있어서,상기 동기화는:상기 동기화된 데이터 객체로서 제 1 데이터 객체를 생성하는 단계;  상기 동기화된 데이터 객체로서 제 2 데이터 객체를 생성하는 단계;더 관련된 데이터 객체로부터 병합 방법을 선택함으로써 상기 동기화된 데이터 객체를 생성하고, 선택된 병합 방법을 사용하여 상기 제 1 데이터 객체의 이력과 상기 제 2 데이터 객체의 이력을 병합하고, 병합된 이력으로부터 현재의 페이로드를 재구성하고, 상기 현재의 페이로드 및 상기 병합된 이력으로 상기 더 관련된 데이터 객체의 페이로드 및 히스토리를 업데이트하고, 덜 관련된 데이터 객체를 폐기하는 단계 중 적어도 하나를 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>88. 제 87항에 있어서,상기 선택은 상기 제 1 및 제 2 데이터 객체의 각각으로부터 속성 중 적어도 하나의 조합을 비교함으로써 상기 제 1 및 제 2 데이터 객체 중에 있는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>89. 제 78항에 있어서,상기 적어도 하나의 카탈로그 객체의 상기 수신, 상기 비교, 상기 적어도 하나의 공유된 데이터 객체의 상기 수신, 상기 동기화, 및 각각의 적어도 하나의 그룹의 각각의 적어도 하나의 멤버의 각각의 적어도 하나의 시스템에 대한 상기 업데이트를 간헐적으로 수행하는 단계를 더 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>90. 제 78항에 있어서,상기 제 1 시스템은 상호연결된 객체 참조에 의해 단독으로 카탈로그로서 작동하는 간접적으로 처리하는 관련된 접근 객체, 카탈로그 객체, 및 맵 객체를 포함하는 처리 그룹 멤버 대신에 처리를 더 수행하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>91. 제 78항에 있어서,상기 적어도 하나의 카탈로그 객체의 상기 수신, 상기 비교, 상기 적어도 하나의 공유된 데이터 객체의 상기 수신, 상기 동기화, 및 적어도 하나의 시스템을 포함하는 보안 네트워크에 걸쳐 각각의 적어도 하나의 그룹의 각각의 적어도 하나의 멤버에 대한 각각의 적어도 하나의 시스템에 대한 상기 업데이트를 간헐적으로 수행하는 단계를 더 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>92. 제 78항에 있어서,상기 그룹 객체에 상기 적어도 하나의 멤버는:또 다른 식별가능한 그룹 객체;식별가능한 영구 저장 시스템;식별가능한 사용자;식별가능한 프로세스;상기 제 1 시스템을 포함하는 식별가능한 시스템;식별가능한 네트워크;식별가능한 하드웨어 시스템;식별가능한 데이터베이스 시스템;식별가능한 데이터 객체;디지털 ID(identity) 중 적어도 하나에 대한 참조인, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>93. 제 78항에 있어서,상기 적어도 하나의 공유된 데이터 객체는 객체 참조를 포함하는 맵 객체인, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>94. 제 78항에 있어서,상기 그룹 객체는 상기 그룹 멤버 가운데 공유하는 보안 데이터를 위한 키 분배 방법을 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>95. 제 94항에 있어서,상기 키 분배 방법은 그룹에서 데이터 흐름을 암호로 제어하는 것을 포함하고, 상기 제어하는 것은:적어도 하나의 프로세서에 의해, 각각의 그룹 멤버에 적어도 하나의 상응하는 키를 분배하는 적어도 하나의 그룹 관리자 및 적어도 하나의 관리자 키에 의해 그룹 멤버의 사각형 크로스 매트릭스를 생성하는 단계, 상기 사각형 크로스 매트릭스는 각기 각각의 행 멤버 및 각각의 열 멤버를 갖는 복수의 요소를 포함하고;적어도 하나의 프로세서에 의해, 키의 조합과 각각의 사각형 크로스 매트릭스 요소를 채우는 단계, 상기 채우는 단계는: 어디에서 상기 행 멤버와 상기 열 멤버가 동일한지를 포함하는 상기 행 멤버 및 상기 열 멤버 사이의 암호화된 양방향 데이터 흐름을 위해 사용되는 적어도 하나의 키를 생성하는 단계; 상기 열 멤버로부터 상기 행 멤버로 암호화된 양방향 데이터 흐름을 위해 사용된 적어도 하나의 키를 생성하는 단계; 및 상기 행 멤버로부터 상기 열 멤버로 암호화된 양방향 데이터 흐름을 위해 사용된 적어도 하나의 키 부분을 복사하고 위치시키는 단계; 중 적어도 하나를 포함하고,상기 적어도 하나의 프로세서에 의해, 상기 사각형 크로스 매트릭스의 적어도 하나의 선택 크로스 매트릭스 요소로부터 적어도 하나의 선택 키를 제거하고, 그로써 상기 적어도 하나의 선택 크로스 매트릭스 요소에 상응하는 그룹 멤버의 쌍 사이에 적어도 하나의 선택 방향에서 암호화된 데이터 흐름을 제한하는 단계;상기 적어도 하나의 프로세서에 의해, 각각의 행에 상응하는 각각의 그룹 멤버에 대해 상기 적어도 하나의 상응하는 키로 복호화되도록 크로스 매트릭스 요소의 각각의 행을 구성하는 단계;상기 적어도 하나의 프로세서에 의해, 적어도 하나의 관리자 키에 의해 복호화되도록 각각의 그룹 멤버에 대해 각각의 적어도 하나의 상응하는 키의 사본을 구성하는 단계; 및상기 적어도 하나의 프로세서에 의해, 상기 적어도 하나의 그룹 관리자에 의해 복호화되도록 상기 적어도 하나의 관리자 키를 구성하는 단계;를 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>96. 제 95항에 있어서,상기 적어도 하나의 그룹 관리자는 적어도 하나의 그룹 멤버를 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>97. 제 95항에 있어서,상기 분배는:상기 그룹 멤버 중 적어도 하나에 대해 상기 적어도 하나의 상응하는 키를 생성하는 단계; 및 상기 적어도 하나의 관리자 키를 생성하는 단계 중 적어도 하나를 더 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>98. 제 95항에 있어서,상기 적어도 하나의 프로세서에 의해, 적어도 하나의 그룹 멤버의 상기 적어도 하나의 상응하는 키로 상기 적어도 하나의 관리자 키의 사본을 암호화함으로써 상기 적어도 하나의 그룹 관리자와는 다른 상기 그룹 멤버로부터 적어도 하나의 제 2 그룹 관리자를 할당하는 단계를 더 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>99. 제 95항에 있어서,상기 적어도 하나의 프로세서에 의해, 상기 적어도 하나의 관리자 키를 사용하여 상기 적어도 하나의 그룹 관리자에 의해 상기 그룹에 신규한 멤버를 추가하는 단계를 더 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>100. 제 95항에 있어서,상기 적어도 하나의 프로세서에 의해, 상기 그룹 멤버의 상기 적어도 하나의 상응하는 키로 복호화되도록 구성된 각각의 그룹 멤버 키에 분배하는 단계를 더 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>101. 제 78항에 있어서,각각의 객체는 데이터 구조이고, 상기 데이터 구조는:적어도 하나의 메모리에 저장된 복수의 잠금 노드(너트)를 포함하고, 상기 잠금 노드의 각각은: 복수의 키 맵을 포함하는 입력 섹션, 상기 키 맵의 각각은 각기 복수의 1차 키 중 상응하는 하나로 암호화되고, 상기 키 맵은 복수의 메인 키를 포함하고; 암호화된 유도 키를 포함하는 가변 잠금 섹션, 상기 암호화된 유도 키는 상기 입력 섹션에 적용된 상기 복수의 1차 키에 상응하는 상기 복수의 메인 키 상의 논리 연산으로부터 유도 키로 복호화되도록 구성되고; 그리고 암호화된 데이터를 포함하는 출력 섹션을 포함하고, 상기 암호화된 데이터는 상기 유도 키로 복호화되도록 구성되고;상기 너트의 적어도 하나의 키홀 잠금 노드는 적어도 하나의 접근 속성 키를 포함하는 상기 1차 키의 각각에 대해 키 맵을 포함하고, 상기 적어도 하나의 접근 속성 키는 상기 너트 내에 상응하는 상기 1차 키에 기반해서 역할 기반 접근 제어를 제공하도록 구성되고; 그리고 상기 잠금 노드 중 적어도 하나는 상기 잠금 노드 중 또 다른 하나에 대한 1차 키인 출력 키를 제공하고;각각의 키 맵은 적어도 하나의 접근 속성 키를 포함하고, 상기 입력 섹션은 적어도 하나의 암호화된 접근 역할 키를 더 포함하고, 상기 적어도 하나의 암호화된 접근 역할 키는 상기 적어도 하나의 접근 속성 키에 의해 복호화되도록 구성되고, 상기 적어도 하나의 접근 역할 키는 데이터 상의 적어도 하나의 작동을 가능하게 하도록 구성되고, 상기 적어도 하나의 접근 역할 키는 특정 키 맵을 초래하는 지정된 1차 키와 연관된 허가에 기반하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>102. 제 101항에 있어서,잠금 노드 중 하나의 입력 섹션에 의해, 잠금 노드의 또 다른 하나에 대한 적어도 하나의 접근 키를 제공하는 단계를 더 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>103. 제 101항에 있어서,상기 잠금 노드 중 하나에 대한 적어도 하나의 키 맵은 적어도 하나의 계층 키를 포함하고, 상기 적어도 하나의 계층 키는 하나의 잠금 노드와는 다른 적어도 하나의 잠금 노드에 대한 다른 키 맵을 복호화하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>104. 제 103항에 있어서,적어도 하나의 계층 키 및 너트에 잠금 노드의 입력 섹션에 의해, 너트 내의 어느 잠금 노드가 특정 지정된 1차 키에 대해 접근가능한지를 제어하는 단계를 더 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>105. 제 101항에 있어서,상기 너트의 적어도 하나의 잠금 노드의 상기 출력 섹션에서, 복수의 다른 어플리케이션을 가로질러 상기 너트의 접근에 관련된 데이터를 저장하는 적어도 하나의 카르나크 섹션을 저장하는 단계를 더 포함하고, 상기 적어도 하나의 카르나크 섹션은:적어도 하나의 카르나크 검토를 포함하고, 각각의 카르나크 검토는:너트의 적어도 하나의 섹션의 과거 검토,상기 너트의 과거 이벤트 로그,상기 카르나크 섹션에 대한 관심의 이벤트의 과거 이벤트 로그, 및적어도 하나의 이벤트가 트리거될 때 처리하도록 구성된 적어도 하나의 명령어를 포함하는 가능한 미래 이벤트 중 적어도 하나이고, 상기 적어도 하나의 명령어를 처리하는 결론은 적어도 하나의 구성가능한 이벤트를 일으키는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>106. 제 105항에 있어서,적어도 하나의 가능한 미래 이벤트는:상기 너트;상기 시스템에 접근가능한 또 다른 데이터 저장 구조;상기 적어도 하나의 명령어의 상기 처리로부터 분리된 프로세스;상기 적어도 하나의 페이로드 섹션;상기 적어도 하나의 카르나크 섹션; 및상기 시스템의 작동 시스템 중 적어도 하나 상에 작동하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>107. 제 105항에 있어서,적어도 하나의 가능한 미래 이벤트는:시스템의 외부에 생성된 적어도 하나의 이벤트;상기 시스템의 내부에 생성된 적어도 하나의 이벤트; 및시간의 기간의 지남에 의해 생성된 적어도 하나의 이벤트 중 적어도 하나에 응답하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>108. 제 101항에 있어서,데이터 상에 허용된 모든 규정된 작동의 연합을 형성하도록 다른 제공된 적어도 하나의 접근 역할 키와 논리 연산에서 상기 적어도 하나의 접근 역할 키를 조합하는 단계를 더 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>109. 제 105항에 있어서,적어도 하나의 카르나크 섹션은 암호화된 형태로 저장되는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>110. 제 105항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 상기 적어도 하나의 카르나크 섹션에서 로그된 것과 로그되지 않은 것을 제어하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>111. 제 105항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 적어도 하나의 카르나크 검토에 세부의 레벨을 제어하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>112. 제 105항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 생성하는 카르나크 검토의 유형을 제어하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>113. 제 112항에 있어서,카르나크 검토의 유형은:상기 너트를 수반하는 처리 이벤트를 수반하는 로그 엔트리;상기 너트에서 상기 데이터를 수반하는 과거 검토 엔트리;상기 너트 상에 작동하는 가능한 미래 이벤트 엔트리;처리 시스템에 접근가능한 또 다른 데이터 저장 구조 상에 작동하는 가능한 미래 이벤트 엔트리;상기 적어도 하나의 명령어의 상기 처리로부터 분리된 프로세스 상에 작동하는 가능한 미래 이벤트 엔트리;상기 시스템의 작동 시스템 상에 작동하는 가능한 미래 이벤트 엔트리;상기 시스템의 외부에 생성된 적어도 하나의 이벤트에 응답하는 가능한 미래 이벤트 엔트리;상기 시스템의 내부에 생성된 적어도 하나의 이벤트에 응답하는 가능한 미래 이벤트 엔트리; 및시간의 기간의 지남에 의해 생성된 적어도 하나의 이벤트에 응답하는 가능한 미래 이벤트 엔트리 중 적어도 하나를 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>114. 제 105항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 카르나크 검토를 생성하는 방법을 제어하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>115. 제 101항에 있어서,상기 적어도 하나의 프로세서에 의해, 상기 그룹 멤버의 상기 적어도 하나의 상응하는 키로 복호화되도록 구성된 각각의 그룹 멤버 너트에 분배하는 단계를 더 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>116. 제 78항에 있어서,각각의 카탈로그 객체 및 각각의 맵 객체는 데이터 구조이고, 상기 데이터 구조는:적어도 하나의 메모리에 저장된 복수의 잠금 노드 (너트), 상기 잠금 노드의 각각은:복수의 키 맵을 포함하는 입력 섹션, 상기 키 맵의 각각은 각기 복수의 1차 키 중 상응하는 하나로 암호화되고, 상기 키 맵은 복수의 메인 키를 포함하고;암호화된 유도 키를 포함하는 가변 잠금 섹션, 상기 암호화된 유도 키는 상기 입력 섹션에 적용된 상기 복수의 1차 키에 상응하는 상기 복수의 메인 키 상의 논리 연산으로부터 유도 키로 복호화되도록 구성되고; 및암호화된 데이터를 포함하는 출력 섹션을 포함하고, 상기 암호화된 데이터는 상기 유도 키로 복호화되도록 구성되고;상기 너트의 적어도 하나의 키홀 잠금 노드는 적어도 하나의 접근 속성 키를 포함하는 1차 키의 각각에 대해 키 맵을 포함하고, 상기 적어도 하나의 접근 속성 키는 상기 너트 내에 상응하는 상기 1차 키에 기반해서 역할 기반 접근 제어를 제공하도록 구성되고; 그리고 상기 잠금 노드 중 적어도 하나는 상기 잠금 노드 중 또 다른 하나에 대한 1차 키인 출력 키를 제공하고; 그리고상기 적어도 하나의 메모리에 저장된 적어도 하나의 유연한 계위 객체 그래프(FHOG) 노드를 포함하고, 상기 적어도 하나의 FHOG 노드는:복수의 FHOG 키 맵을 포함하는 FHOG 입력 섹션, 상기 FHOG 키 맵의 각각은 각기 복수의 1차 FHOG 키 중 상응하는 하나로 암호화되고, 상기 FHOG 키 맵은 복수의 메인 FHOG 키를 포함하고;FHOG 암호화된 유도 키를 포함하는 FHOG 가변 잠금 섹션, 상기 FHOG 암호화된 유도 키는 상기 FHOG 입력 섹션에 적용된 상기 복수의 1차 FHOG 키에 상응하는 상기 복수의 메인 FHOG 키 상의 논리 연산으로부터 유도 키로 복호화되도록 구성되고; 그리고암호화된 참조 세트를 포함하는 FHOG 출력 섹션을 포함하고, 암호화된 참조 세트는 FHOG 유도 키로 복호화되도록 구성되고, 참조 세트는 너트를 포함하는 참조 기반 파일 시스템을 집합적으로 규정하는 너트의 각각에 대한 참조를 포함하고;각각의 키 맵은 적어도 하나의 접근 속성 키를 포함하고, 상기 입력 섹션은 적어도 하나의 암호화된 접근 역할 키를 더 포함하고, 상기 적어도 하나의 암호화된 접근 역할 키는 상기 적어도 하나의 접근 속성 키에 의해 복호화되도록 구성되고, 적어도 하나의 접근 역할 키는 데이터 상의 적어도 하나의 작동을 가능하게 하도록 구성되고, 상기 적어도 하나의 접근 역할 키는 특정 키 맵을 초래하는 지정된 1차 키와 연관된 허가에 기반하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>117. 제 116항에 있어서,디지털 자원에 대한 적어도 하나의 참조는 상기 디지털 자원과 연관된 적어도 하나의 속성을 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>118. 제 116항에 있어서,디지털 자원에 대한 적어도 하나의 참조는 또 다른 디지털 자원에 대한 적어도 하나의 참조를 참조하는 적어도 하나의 속성을 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>119. 제 116항에 있어서,상기 잠금 노드 중 하나의 상기 입력 섹션에 의해, 상기 잠금 노드의 또 다른 하나에 대한 적어도 하나의 접근 키를 제공하는 단계를 더 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>120. 제 116항에 있어서,상기 잠금 노드 중 하나에 대한 적어도 하나의 키 맵은 적어도 하나의 계층 키를 포함하고, 상기 적어도 하나의 계층 키는 하나의 잠금 노드와는 다른 적어도 하나의 잠금 노드에 대한 다른 키 맵을 복호화하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>121. 제 120항에 있어서,상기 너트에 잠금 노드의 상기 적어도 하나의 계층 키 및 상기 입력 섹션에 의해, 상기 너트 내의 어느 잠금 노드가 특정 지정된 1차 키에 대해 접근가능한지를 제어하는 단계를 더 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>122. 제 116항에 있어서,데이터 상에 허용된 모든 규정된 작동의 연합을 형성하도록 다른 제공된 적어도 하나의 접근 역할 키와 논리 연산에서 상기 적어도 하나의 접근 역할 키를 조합하는 단계를 더 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>123. 제 116항에 있어서,상기 너트의 적어도 하나의 잠금 노드의 출력 섹션에서, 복수의 다른 어플리케이션을 가로질러 상기 너트의 접근에 관련된 데이터를 저장하는 적어도 하나의 카르나크 섹션을 저장하는 단계를 더 포함하고, 상기 적어도 하나의 카르나크 섹션은:적어도 하나의 카르나크 검토를 포함하고, 각각의 카르나크 검토는:상기 너트의 적어도 하나의 섹션의 과거 검토,상기 너트의 과거 이벤트 로그,상기 카르나크 섹션에 대한 관심의 이벤트의 과거 이벤트 로그, 및적어도 하나의 이벤트가 트리거될 때 처리하도록 구성된 적어도 하나의 명령어를 포함하는 가능한 미래 이벤트 중 적어도 하나이고, 상기 적어도 하나의 명령어를 처리하는 결론은 적어도 하나의 구성가능한 이벤트를 일으키는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>124. 제 123항에 있어서,상기 적어도 하나의 가능한 미래 이벤트는:상기 너트;시스템에 접근가능한 또 다른 데이터 저장 구조;상기 적어도 하나의 명령어의 상기 처리로부터 분리된 프로세스;적어도 하나의 페이로드 섹션;상기 적어도 하나의 카르나크 섹션; 및상기 시스템의 작동 시스템 중 적어도 하나 상에 작동하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>125. 제 123항에 있어서,적어도 하나의 가능한 미래 이벤트는:시스템의 외부에 생성된 적어도 하나의 이벤트;상기 시스템의 내부에 생성된 적어도 하나의 이벤트; 및시간의 기간의 지남에 의해 생성된 적어도 하나의 이벤트 중 적어도 하나에 응답하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>126. 제 123항에 있어서,상기 적어도 하나의 카르나크 섹션은 암호화된 형태로 저장되는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>127. 제 123항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 상기 적어도 하나의 카르나크 섹션에서 로그된 것과 로그되지 않은 것을 제어하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>128. 제 123항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 상기 적어도 하나의 카르나크 검토에 세부의 레벨을 제어하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>129. 제 123항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 생성하는 카르나크 검토의 유형을 제어하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>130. 제 129항에 있어서,상기 카르나크 검토의 유형은:상기 너트를 수반하는 이벤트를 처리하는 것을 수반하는 로그 엔트리;상기 너트에서 상기 데이터를 수반하는 과거 검토 엔트리;상기 너트 상에 작동하는 가능한 미래 이벤트 엔트리;처리 시스템에 접근가능한 또 다른 데이터 저장 구조 상에 작동하는 가능한 미래 이벤트 엔트리;상기 적어도 하나의 명령어의 상기 처리로부터 분리된 프로세스 상에 작동하는 가능한 미래 이벤트 엔트리;시스템의 작동 시스템 상에 작동하는 가능한 미래 이벤트 엔트리;상기 시스템의 외부에 생성된 적어도 하나의 이벤트에 응답하는 가능한 미래 이벤트 엔트리;상기 시스템의 내부에 생성된 적어도 하나의 이벤트에 응답하는 가능한 미래 이벤트 엔트리; 및시간의 기간의 지남에 의해 생성된 적어도 하나의 이벤트에 응답하는 가능한 미래 이벤트 엔트리 중 적어도 하나를 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>131. 제 123항에 있어서,상기 너트에 저장된 적어도 하나의 파라미터는 카르나크 검토를 생성하는 방법을 제어하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>132. 제 116항에 있어서,상기 참조 세트는 너트 식별자의 목록을 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>133. 제 116항에 있어서,상기 참조 세트는 너트 페이로드 유형의 목록을 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>134. 제 116항에 있어서,상기 파일 시스템은 상기 너트의 물리적 위치와 독립적으로 규정되는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>135. 제 116항에 있어서,상기 1차 FHOG 키와 연관된 허가는 각각의 참조된 너트의 상기 1차 키와 연관된 상기 허가로부터 독립적인, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo><claimInfo><claim>136. 제 116항에 있어서,상기 FHOG 출력 섹션은 상기 FHOG 유도 키로 복호화하도록 구성된 다른 암호화된 데이터를 더 포함하는, 적어도 하나의 루프백 도관을 작동시킴으로써 그룹에서 공유된 데이터 객체를 동기화하는 방법.</claim></claimInfo></claimInfoArray><applicantInfoArray><applicantInfo><address>미국 일리노이 ***** 글렌코 버논 애비뉴 ***</address><code>520190090962</code><country>미국</country><engName>NUTS HOLDINGS, LLC</engName><name>너츠 홀딩스 엘엘씨</name></applicantInfo></applicantInfoArray><inventorInfoArray><inventorInfo><address>미국 일리노이 ***** 글렌...</address><code> </code><country> </country><engName>AUH, Yoon, Ho</engName><name>어윤호</name></inventorInfo><inventorInfo><address>미국 일리노이 ***** 글렌...</address><code> </code><country> </country><engName>BENNIG, Nicholas</engName><name>베니그 니콜라스</name></inventorInfo><inventorInfo><address>미국 일리노이 ***** 글렌...</address><code> </code><country> </country><engName>TRIANTAFILLOU, Sotirios</engName><name>트리안타필로우 소티리오스</name></inventorInfo></inventorInfoArray><agentInfoArray><agentInfo><address>서울 강남구 언주로 **길 **, *층, **층, **층, **층(도곡동, 대림아크로텔)</address><code>920051000028</code><country>대한민국</country><engName>Y.P.LEE,MOCK&amp;PARTNERS</engName><name>리앤목특허법인</name></agentInfo></agentInfoArray><priorityInfoArray><priorityInfo><priorityApplicationCountry>미국</priorityApplicationCountry><priorityApplicationDate>2020.04.09</priorityApplicationDate><priorityApplicationNumber>63/007,636</priorityApplicationNumber></priorityInfo></priorityInfoArray><designatedStateInfoArray/><priorArtDocumentsInfoArray/><legalStatusInfoArray><legalStatusInfo><commonCodeName>수리 (Accepted) </commonCodeName><documentEngName>[Patent Application] Document according to the Article 203 of Patent Act</documentEngName><documentName>[특허출원]특허법 제203조에 따른 서면</documentName><receiptDate>2022.11.03</receiptDate><receiptNumber>1-1-2022-1166968-94</receiptNumber></legalStatusInfo><legalStatusInfo><commonCodeName>발송처리완료 (Completion of Transmission) </commonCodeName><documentEngName>Request for Amendment</documentEngName><documentName>보정요구서</documentName><receiptDate>2022.11.15</receiptDate><receiptNumber>1-5-2022-0171499-69</receiptNumber></legalStatusInfo><legalStatusInfo><commonCodeName>수리 (Accepted) </commonCodeName><documentEngName>[Amendment to Patent Application, etc.] Amendment</documentEngName><documentName>[출원서 등 보정]보정서</documentName><receiptDate>2023.01.05</receiptDate><receiptNumber>1-1-2023-0017966-53</receiptNumber></legalStatusInfo><legalStatusInfo><commonCodeName>발송처리완료 (Completion of Transmission) </commonCodeName><documentEngName>Notice of Acceptance</documentEngName><documentName>수리안내서</documentName><receiptDate>2023.01.10</receiptDate><receiptNumber>1-5-2023-0005541-20</receiptNumber></legalStatusInfo><legalStatusInfo><commonCodeName>수리 (Accepted) </commonCodeName><documentEngName> </documentEngName><documentName>[심사청구]심사청구서·우선심사신청서</documentName><receiptDate>2024.03.05</receiptDate><receiptNumber>1-1-2024-0250912-98</receiptNumber></legalStatusInfo><legalStatusInfo><commonCodeName>보정승인간주 (Regarded as an acceptance of amendment) </commonCodeName><documentEngName>[Amendment to Description, etc.] Amendment</documentEngName><documentName>[명세서등 보정]보정서</documentName><receiptDate>2024.03.05</receiptDate><receiptNumber>1-1-2024-0250913-33</receiptNumber></legalStatusInfo></legalStatusInfoArray><imagePathInfo><docName>1020227038535.jpg</docName><largePath>http://plus.kipris.or.kr/kiprisplusws/fileToss.jsp?arg=6c650beb4cee9ce4122b704b88878c932103a4090ff727c6ca97d78ebc7f4a4e9e55d2418ed2668eb91f00e8d2f98ccf25818fca970dd855f47e1e23543940a01c205cd0a10231ec</largePath><path>http://plus.kipris.or.kr/kiprisplusws/fileToss.jsp?arg=ed43a0609e94d6e22d01c5c32ba711cf0d90a09e6647343c93a6c6e2e2267594edab9fc30f8a832113957c1903dd84a612ed9ea3e1f4483ce7b8b5c7e01cdf491e1906a68b21c69c</path></imagePathInfo><rndInfoArray/></item></body><count><numOfRows>1</numOfRows><pageNo>1</pageNo><totalCount>1</totalCount></count></response>