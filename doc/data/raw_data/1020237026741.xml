<?xml version="1.0" encoding="UTF-8" standalone="yes"?><response><header><requestMsgID></requestMsgID><responseTime>2025-11-17 17:54:53.5453</responseTime><responseMsgID></responseMsgID><successYN>Y</successYN><resultCode>00</resultCode><resultMsg>NORMAL SERVICE.</resultMsg></header><body><item><biblioSummaryInfoArray><biblioSummaryInfo><applicationDate>2022.01.10</applicationDate><applicationFlag> </applicationFlag><applicationNumber>10-2023-7026741</applicationNumber><claimCount>22</claimCount><examinerName> </examinerName><finalDisposal> </finalDisposal><inventionTitle>비디오 코딩에서의 인트라-예측을 위한 레퍼런스 픽셀들의 업샘플링</inventionTitle><inventionTitleEng>UPSAMPLING REFERENCE PIXELS FOR INTRA-PREDICTION IN VIDEO CODING</inventionTitleEng><openDate>2023.10.17</openDate><openNumber>10-2023-0145063</openNumber><originalApplicationDate> </originalApplicationDate><originalApplicationKind>국제출원/신규</originalApplicationKind><originalApplicationNumber> </originalApplicationNumber><originalExaminationRequestDate>2024.12.24</originalExaminationRequestDate><originalExaminationRequestFlag>Y</originalExaminationRequestFlag><publicationDate> </publicationDate><publicationNumber> </publicationNumber><registerDate> </registerDate><registerNumber> </registerNumber><registerStatus>공개</registerStatus><translationSubmitDate>2023.08.04</translationSubmitDate></biblioSummaryInfo></biblioSummaryInfoArray><ipcInfoArray><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/132</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/157</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/176</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/593</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/70</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/196</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/59</ipcNumber></ipcInfo></ipcInfoArray><familyInfoArray><familyInfo/></familyInfoArray><abstractInfoArray><abstractInfo><astrtCont> 비디오 데이터를 디코딩하기 위한 디바이스는, 비디오 데이터를 저장하도록 구성된 메모리; 및 회로부에서 구현된 하나 이상의 프로세서들을 포함하고, 하나 이상의 프로세서들은, 비디오 데이터의 현재 블록이 각도 인트라-예측 모드를 사용하여 예측될 것임을 결정하고; 각도 인트라-예측 모드의 각도에 따라 현재 블록에 대한 예측 블록을 생성하는데 사용될 그리고 업샘플링될 현재 블록에 대한 이웃 샘플들을 결정하고; 예측 블록을 생성하는데 사용될 이웃 샘플들을 공동으로 업샘플링하고 그리고 예측된 샘플들에 대한 값들을 생성하는 공식들에 따라 예측 블록의 예측된 샘플들을 계산하고; 그리고 예측 블록을 사용하여 현재 블록을 디코딩하도록 구성된다. </astrtCont></abstractInfo></abstractInfoArray><internationalInfoArray><internationalInfo><internationOpenDate>2022.08.18</internationOpenDate><internationOpenNumber>WO2022173539</internationOpenNumber><internationalApplicationDate>2022.01.10</internationalApplicationDate><internationalApplicationNumber>PCT/US2022/011833</internationalApplicationNumber></internationalInfo></internationalInfoArray><claimInfoArray><claimInfo><claim>1. 비디오 데이터를 디코딩하는 방법으로서,비디오 데이터의 현재 블록이 각도 인트라-예측 모드를 사용하여 예측될 것임을 결정하는 단계;상기 각도 인트라-예측 모드의 각도에 따라 상기 현재 블록에 대한 예측 블록을 생성하는데 사용될 그리고 업샘플링될 상기 현재 블록에 대한 이웃 샘플들을 결정하는 단계;상기 예측 블록을 생성하는데 사용될 상기 이웃 샘플들을 공동으로 업샘플링하고 그리고 예측된 샘플들에 대한 값들을 생성하는 공식들에 따라 상기 예측 블록의 상기 예측된 샘플들을 계산하는 단계; 및상기 예측 블록을 사용하여 상기 현재 블록을 디코딩하는 단계를 포함하는, 비디오 데이터를 디코딩하는 방법.</claim></claimInfo><claimInfo><claim>2. 제 1 항에 있어서,상기 예측 블록의 상기 예측된 샘플들을 계산하는 단계는,상기 현재 블록에 대한 상위 이웃 샘플들을 사용하여 상기 예측된 샘플들의 상부 이웃 경로 계산을 수행하는 단계로서, 상기 예측 블록의 각각의 샘플에 대해: 인덱스 X 값 (idxX = (j003c#003c#6) + ( i + 1 ) * dx) 을 계산하는 단계로서, j 는 현재 샘플에 대한 행 포지션 값을 나타내고, i 는 상기 현재 샘플에 대한 열 포지션 값을 나타내고, dx 는 상기 각도 인트라-예측 모드의 각도에 따른 수평 포지션 스칼라 값을 나타내는, 상기 인덱스 X 값을 계산하는 단계; maxBaseX = (w + h - 1) 003c#003c# upsampleAbove 에 따라 최대 베이스 X 값을 계산하는 단계로서, w 는 상기 현재 블록의 폭을 나타내고, h 는 상기 현재 블록의 높이를 나타내고, upsampleAbove 는 상기 예측 블록을 생성하는데 사용될 그리고 업샘플링될 상기 이웃 샘플들의 결정에 따라 상기 상위 이웃 샘플들이 업샘플링될지 여부를 표시하는 값을 나타내고, '003c#003c#' 는 비트단위 좌측 시프트 연산자를 나타내는, 상기 최대 베이스 X 값을 계산하는 단계; baseX = min (maxBaseX, (idxX 003e#003e# ( 6 - upsampleAbove))) 에 따라 베이스 X 값을 계산하는 단계; 및 shiftX = ( (idxX 003c#003c# upsampleAbove) 003e#003e# 1 ) 0026# 0x1F 에 따라 시프트 X 값을 계산하는 단계로서, '003e#003e#' 는 비트단위 우측 시프트 연산자를 나타내고 '0026#' 는 비트단위 AND 연산자를 나타내는, 상기 시프트 X 값을 계산하는 단계를 포함하는, 상기 예측된 샘플들의 상부 이웃 경로 계산을 수행하는 단계;상기 현재 블록에 대한 좌측 이웃 샘플들을 사용하여 상기 예측된 샘플들의 좌측 이웃 경로 계산을 수행하는 단계로서, 상기 예측 블록의 각각의 샘플에 대해: 인덱스 Y 값 (idxY = (i003c#003c#6) + ( j + 1 ) * dy) 을 계산하는 단계로서, dy 는 상기 각도 인트라-예측 모드의 각도에 따른 수직 포지션 스칼라 값을 나타내는, 상기 인덱스 Y 값을 계산하는 단계; maxBaseY = (w + h - 1) 003c#003c# upsampleLeft 에 따라 최대 베이스 Y 값을 계산하는 단계로서, upsampleLeft 는 상기 예측 블록을 생성하는데 사용될 그리고 업샘플링될 상기 이웃 샘플들의 결정에 따라 상기 좌측 이웃 샘플들이 업샘플링될지 여부를 표시하는 값을 나타내는, 상기 최대 베이스 Y 값을 계산하는 단계; baseY = min (maxBaseY, (idxY 003e#003e# ( 6 - upsampleLeft))) 에 따라 베이스 Y 값을 계산하는 단계; 및 shiftY = ( (idxY 003c#003c# upsampleLeft) 003e#003e# 1 ) 0026# 0x1F 에 따라 시프트 Y 값을 계산하는 단계로서, '003e#003e#' 는 비트단위 우측 시프트 연산자를 나타내고 '0026#' 는 비트단위 AND 연산자를 나타내는, 상기 시프트 Y 값을 계산하는 단계를 포함하는, 상기 예측된 샘플들의 좌측 이웃 경로 계산을 수행하는 단계; 및상기 예측 블록의 각각의 샘플에 대해: base = (baseX 003e#= -(1003c#003c#upsampleAbove)) ? baseX : baseY 에 따라 베이스 포지션 값을 계산하는 단계; shift = (baseX 003e#= -(1003c#003c#upsampleAbove)) ? shiftX : shiftY 에 따라 시프트 값을 계산하는 단계; 및 상기 베이스 포지션 값 및 상기 시프트 값을 사용하여 상기 예측 블록에서 포지션 (i, j) 에서의 예측 샘플에 대한 값을 계산하는 단계를 포함하는, 비디오 데이터를 디코딩하는 방법.</claim></claimInfo><claimInfo><claim>3. 제 2 항에 있어서,상기 포지션 (i, j) 에서의 상기 예측 샘플에 대한 값을 계산하는 단계는,상기 포지션 (i, j) 에서의 상기 예측 샘플에 대한 상기 베이스 포지션 값에 따라 4개의 인접한 샘플들을 결정하는 단계; 및상기 4개의 인접한 샘플들을 사용하여 상기 예측 샘플에 대한 값을 계산하는 단계를 포함하는, 비디오 데이터를 디코딩하는 방법.</claim></claimInfo><claimInfo><claim>4. 제 3 항에 있어서,상기 4개의 인접한 샘플들을 결정하는 단계는 상기 베이스 포지션 값 마이너스 1 에서의 p1, 베이스 포지션에서의 p2, 상기 베이스 포지션 값 플러스 1 에서의 p3, 및 상기 베이스 포지션 값 플러스 2 에서의 p4 를 포함하는 것으로서 상기 4개의 인접한 샘플들을 결정하는 단계를 포함하고,상기 4개의 인접한 샘플들을 사용하여 상기 예측 샘플에 대한 값을 계산하는 단계는: 베이스 값이 홀수일 때 refpix_a 가 (9*(p1+p2) - (p0+p3)) 과 동일한 것, 또는 상기 베이스 값이 짝수일 때 refpix_a 가 p1 과 동일한 것에 따라 값 refpix_a 를 계산하는 단계; 상기 베이스 값이 홀수일 때 refpix_b 가 p2 와 동일한 것, 또는 상기 베이스 값이 짝수일 때 refpix_b 가 (9*(p1+p2) - (p0+p3)) 과 동일한 것에 따라 값 refpix_b 를 계산하는 단계; 및 pred[i][j] = Clip(0, max_pixel_value, Round2( refpix_a * ( 32 - shift ) + refpix_b * shift, 5 )) 에 따라 상기 포지션 (i, j) 에서의 상기 예측 샘플에 대한 값 (pred[i][j]) 을 계산하는 단계를 포함하는, 비디오 데이터를 디코딩하는 방법.</claim></claimInfo><claimInfo><claim>5. 제 1 항에 있어서,상기 현재 블록을 디코딩하기 전에 상기 예측 블록을 사용하여 상기 현재 블록을 인코딩하는 단계를 더 포함하는, 비디오 데이터를 디코딩하는 방법.</claim></claimInfo><claimInfo><claim>6. 비디오 데이터를 디코딩하기 위한 디바이스로서,비디오 데이터를 저장하도록 구성된 메모리; 및회로부에서 구현된 하나 이상의 프로세서들을 포함하고,상기 하나 이상의 프로세서들은,상기 비디오 데이터의 현재 블록이 각도 인트라-예측 모드를 사용하여 예측될 것임을 결정하고; 상기 각도 인트라-예측 모드의 각도에 따라 상기 현재 블록에 대한 예측 블록을 생성하는데 사용될 그리고 업샘플링될 상기 현재 블록에 대한 이웃 샘플들을 결정하고;상기 예측 블록을 생성하는데 사용될 상기 이웃 샘플들을 공동으로 업샘플링하고 그리고 예측된 샘플들에 대한 값들을 생성하는 공식들에 따라 상기 예측 블록의 상기 예측된 샘플들을 계산하고; 그리고상기 예측 블록을 사용하여 상기 현재 블록을 디코딩하도록구성되는, 비디오 데이터를 디코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>7. 제 6 항에 있어서,상기 예측 블록의 상기 예측된 샘플들을 계산하기 위해, 상기 하나 이상의 프로세서들은,상기 현재 블록에 대한 상위 이웃 샘플들을 사용하여 상기 예측된 샘플들의 상부 이웃 경로 계산을 수행하는 것으로서, 상기 예측 블록의 각각의 샘플에 대해: 인덱스 X 값 (idxX = (j003c#003c#6) + ( i + 1 ) * dx) 을 계산하는 것으로서, j 는 현재 샘플에 대한 행 포지션 값을 나타내고, i 는 상기 현재 샘플에 대한 열 포지션 값을 나타내고, dx 는 상기 각도 인트라-예측 모드의 각도에 따른 수평 포지션 스칼라 값을 나타내는, 상기 인덱스 X 값을 계산하는 것; maxBaseX = (w + h - 1) 003c#003c# upsampleAbove 에 따라 최대 베이스 X 값을 계산하는 것으로서, w 는 상기 현재 블록의 폭을 나타내고, h 는 상기 현재 블록의 높이를 나타내고, upsampleAbove 는 상기 예측 블록을 생성하는데 사용될 그리고 업샘플링될 상기 이웃 샘플들의 결정에 따라 상기 상위 이웃 샘플들이 업샘플링될지 여부를 표시하는 값을 나타내고, '003c#003c#' 는 비트단위 좌측 시프트 연산자를 나타내는, 상기 최대 베이스 X 값을 계산하는 것; baseX = min (maxBaseX, (idxX 003e#003e# ( 6 - upsampleAbove))) 에 따라 베이스 X 값을 계산하는 것; 및 shiftX = ( (idxX 003c#003c# upsampleAbove) 003e#003e# 1 ) 0026# 0x1F 에 따라 시프트 X 값을 계산하는 것으로서, '003e#003e#' 는 비트단위 우측 시프트 연산자를 나타내고 '0026#' 는 비트단위 AND 연산자를 나타내는, 상기 시프트 X 값을 계산하는 것을 포함하는, 상기 예측된 샘플들의 상부 이웃 경로 계산을 수행하고;상기 현재 블록에 대한 좌측 이웃 샘플들을 사용하여 상기 예측된 샘플들의 좌측 이웃 경로 계산을 수행하는 것으로서, 상기 예측 블록의 각각의 샘플에 대해: 인덱스 Y 값 (idxY = (i003c#003c#6) + ( j + 1 ) * dy) 을 계산하는 것으로서, dy 는 상기 각도 인트라-예측 모드의 각도에 따른 수직 포지션 스칼라 값을 나타내는, 상기 인덱스 Y 값을 계산하는 것; maxBaseY = (w + h - 1) 003c#003c# upsampleLeft 에 따라 최대 베이스 Y 값을 계산하는 것으로서, upsampleLeft 는 상기 예측 블록을 생성하는데 사용될 그리고 업샘플링될 상기 이웃 샘플들의 결정에 따라 상기 좌측 이웃 샘플들이 업샘플링될지 여부를 표시하는 값을 나타내는, 상기 최대 베이스 Y 값을 계산하는 것; baseY = min (maxBaseY, (idxY 003e#003e# ( 6 - upsampleLeft))) 에 따라 베이스 Y 값을 계산하는 것; 및 shiftY = ( (idxY 003c#003c# upsampleLeft) 003e#003e# 1 ) 0026# 0x1F 에 따라 시프트 Y 값을 계산하는 것으로서, '003e#003e#' 는 비트단위 우측 시프트 연산자를 나타내고 '0026#' 는 비트단위 AND 연산자를 나타내는, 상기 시프트 Y 값을 계산하는 것을 포함하는, 상기 예측된 샘플들의 좌측 이웃 경로 계산을 수행하고; 그리고상기 예측 블록의 각각의 샘플에 대해:  base = (baseX 003e#= -(1003c#003c#upsampleAbove)) ? baseX : baseY 에 따라 베이스 포지션 값을 계산하고; shift = (baseX 003e#= -(1003c#003c#upsampleAbove)) ? shiftX : shiftY 에 따라 시프트 값을 계산하고; 그리고 베이스 값 및 상기 시프트 값을 사용하여 상기 예측 블록에서 포지션 (i, j) 에서의 예측 샘플에 대한 값을 계산하도록구성되는, 비디오 데이터를 디코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>8. 제 7 항에 있어서,상기 포지션 (i, j) 에서의 상기 예측 샘플에 대한 값을 계산하기 위해, 상기 하나 이상의 프로세서들은,상기 포지션 (i, j) 에서의 상기 예측 샘플에 대한 상기 베이스 포지션 값에 따라 4개의 인접한 샘플들을 결정하고; 그리고상기 4개의 인접한 샘플들을 사용하여 상기 예측 샘플에 대한 값을 계산하도록구성되는, 비디오 데이터를 디코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>9. 제 8 항에 있어서,상기 하나 이상의 프로세서들은, 상기 베이스 포지션 값 마이너스 1 에서의 p1, 베이스 포지션에서의 p2, 상기 베이스 포지션 값 플러스 1 에서의 p3, 및 상기 베이스 포지션 값 플러스 2 에서의 p4 를 포함하는 것으로서 상기 4개의 인접한 샘플들을 결정하도록 구성되고,상기 4개의 인접한 샘플들을 사용하여 상기 예측 샘플에 대한 값을 계산하기 위해, 상기 하나 이상의 프로세서들은: 베이스 값이 홀수일 때 refpix_a 가 (9*(p1+p2) - (p0+p3)) 과 동일한 것, 또는 상기 베이스 값이 짝수일 때 refpix_a 가 p1 과 동일한 것에 따라 값 refpix_a 를 계산하고; 상기 베이스 값이 홀수일 때 refpix_b 가 p2 와 동일한 것, 또는 상기 베이스 값이 짝수일 때 refpix_b 가 (9*(p1+p2) - (p0+p3)) 과 동일한 것에 따라 값 refpix_b 를 계산하고; 그리고 pred[i][j] = Clip(0, max_pixel_value, Round2( refpix_a * ( 32 - shift ) + refpix_b * shift, 5 )) 에 따라 상기 포지션 (i, j) 에서의 상기 예측 샘플에 대한 값 (pred[i][j]) 을 계산하도록구성되는, 비디오 데이터를 디코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>10. 제 6 항에 있어서,상기 하나 이상의 프로세서들은, 상기 현재 블록을 디코딩하기 전에 상기 예측 블록을 사용하여 상기 현재 블록을 인코딩하도록 구성되는, 비디오 데이터를 디코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>11. 제 6 항에 있어서,디코딩된 비디오 데이터를 디스플레이하도록 구성된 디스플레이를 더 포함하는, 비디오 데이터를 디코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>12. 제 6 항에 있어서,상기 디바이스는 카메라, 컴퓨터, 모바일 디바이스, 브로드캐스트 수신기 디바이스, 또는 셋탑 박스 중 하나 이상을 포함하는, 비디오 데이터를 디코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>13. 명령들이 저장된 컴퓨터 판독가능 저장 매체로서,상기 명령들은, 실행될 경우, 비디오 데이터를 디코딩하기 위한 디바이스의 프로세서로 하여금:비디오 데이터의 현재 블록이 각도 인트라-예측 모드를 사용하여 예측될 것임을 결정하게 하고;상기 각도 인트라-예측 모드의 각도에 따라 상기 현재 블록에 대한 예측 블록을 생성하는데 사용될 그리고 업샘플링될 상기 현재 블록에 대한 이웃 샘플들을 결정하게 하고;상기 예측 블록을 생성하는데 사용될 상기 이웃 샘플들을 공동으로 업샘플링하고 그리고 예측된 샘플들에 대한 값들을 생성하는 공식들에 따라 상기 예측 블록의 상기 예측된 샘플들을 계산하게 하고; 그리고상기 예측 블록을 사용하여 상기 현재 블록을 디코딩하게 하는, 컴퓨터 판독가능 저장 매체.</claim></claimInfo><claimInfo><claim>14. 제 13 항에 있어서,상기 프로세서로 하여금 상기 예측 블록의 상기 예측된 샘플들을 계산하게 하는 명령들은, 상기 프로세서로 하여금:상기 현재 블록에 대한 상위 이웃 샘플들을 사용하여 상기 예측된 샘플들의 상부 이웃 경로 계산을 수행하게 하는 것으로서, 상기 예측 블록의 각각의 샘플에 대해: 인덱스 X 값 (idxX = (j003c#003c#6) + ( i + 1 ) * dx) 을 계산하는 것으로서, j 는 현재 샘플에 대한 행 포지션 값을 나타내고, i 는 상기 현재 샘플에 대한 열 포지션 값을 나타내고, dx 는 상기 각도 인트라-예측 모드의 각도에 따른 수평 포지션 스칼라 값을 나타내는, 상기 인덱스 X 값을 계산하는 것; maxBaseX = (w + h - 1) 003c#003c# upsampleAbove 에 따라 최대 베이스 X 값을 계산하는 것으로서, w 는 상기 현재 블록의 폭을 나타내고, h 는 상기 현재 블록의 높이를 나타내고, upsampleAbove 는 상기 예측 블록을 생성하는데 사용될 그리고 업샘플링될 상기 이웃 샘플들의 결정에 따라 상기 상위 이웃 샘플들이 업샘플링될지 여부를 표시하는 값을 나타내고, '003c#003c#' 는 비트단위 좌측 시프트 연산자를 나타내는, 상기 최대 베이스 X 값을 계산하는 것; baseX = min (maxBaseX, (idxX 003e#003e# ( 6 - upsampleAbove))) 에 따라 베이스 X 값을 계산하는 것; 및 shiftX = ( (idxX 003c#003c# upsampleAbove) 003e#003e# 1 ) 0026# 0x1F 에 따라 시프트 X 값을 계산하는 것으로서, '003e#003e#' 는 비트단위 우측 시프트 연산자를 나타내고 '0026#' 는 비트단위 AND 연산자를 나타내는, 상기 시프트 X 값을 계산하는 것을 포함하는, 상기 예측된 샘플들의 상부 이웃 경로 계산을 수행하게 하고;상기 현재 블록에 대한 좌측 이웃 샘플들을 사용하여 상기 예측된 샘플들의 좌측 이웃 경로 계산을 수행하게 하는 것으로서, 상기 예측 블록의 각각의 샘플에 대해: 인덱스 Y 값 (idxY = (i003c#003c#6) + ( j + 1 ) * dy) 을 계산하는 것으로서, dy 는 상기 각도 인트라-예측 모드의 각도에 따른 수직 포지션 스칼라 값을 나타내는, 상기 인덱스 Y 값을 계산하는 것; maxBaseY = (w + h - 1) 003c#003c# upsampleLeft 에 따라 최대 베이스 Y 값을 계산하는 것으로서, upsampleLeft 는 상기 예측 블록을 생성하는데 사용될 그리고 업샘플링될 상기 이웃 샘플들의 결정에 따라 상기 좌측 이웃 샘플들이 업샘플링될지 여부를 표시하는 값을 나타내는, 상기 최대 베이스 Y 값을 계산하는 것; baseY = min (maxBaseY, (idxY 003e#003e# ( 6 - upsampleLeft))) 에 따라 베이스 Y 값을 계산하는 것; 및 shiftY = ( (idxY 003c#003c# upsampleLeft) 003e#003e# 1 ) 0026# 0x1F 에 따라 시프트 Y 값을 계산하는 것으로서, '003e#003e#' 는 비트단위 우측 시프트 연산자를 나타내고 '0026#' 는 비트단위 AND 연산자를 나타내는, 상기 시프트 Y 값을 계산하는 것을 포함하는, 상기 예측된 샘플들의 좌측 이웃 경로 계산을 수행하게 하고; 그리고상기 예측 블록의 각각의 샘플에 대해: base = (baseX 003e#= -(1003c#003c#upsampleAbove)) ? baseX : baseY 에 따라 베이스 포지션 값을 계산하게 하고; shift = (baseX 003e#= -(1003c#003c#upsampleAbove)) ? shiftX : shiftY 에 따라 시프트 값을 계산하게 하고; 그리고 베이스 값 및 상기 시프트 값을 사용하여 상기 예측 블록에서 포지션 (i, j) 에서의 예측 샘플에 대한 값을 계산하게 하는명령들을 포함하는, 컴퓨터 판독가능 저장 매체.</claim></claimInfo><claimInfo><claim>15. 제 14 항에 있어서,상기 프로세서로 하여금 상기 포지션 (i, j) 에서의 상기 예측 샘플에 대한 값을 계산하게 하는 명령들은, 상기 프로세서로 하여금:상기 포지션 (i, j) 에서의 상기 예측 샘플에 대한 상기 베이스 포지션 값에 따라 4개의 인접한 샘플들을 결정하게 하고; 그리고상기 4개의 인접한 샘플들을 사용하여 상기 예측 샘플에 대한 값을 계산하게 하는명령들을 포함하는, 컴퓨터 판독가능 저장 매체.</claim></claimInfo><claimInfo><claim>16. 제 15 항에 있어서,상기 프로세서로 하여금 상기 4개의 인접한 샘플들을 결정하게 하는 명령들은, 상기 프로세서로 하여금 상기 베이스 포지션 값 마이너스 1 에서의 p1, 베이스 포지션에서의 p2, 상기 베이스 포지션 값 플러스 1 에서의 p3, 및 상기 베이스 포지션 값 플러스 2 에서의 p4 를 포함하는 것으로서 상기 4개의 인접한 샘플들을 결정하게 하는 명령들을 포함하고,상기 프로세서로 하여금 상기 4개의 인접한 샘플들을 사용하여 상기 예측 샘플에 대한 값을 계산하게 하는 명령들은, 상기 프로세서로 하여금: 베이스 값이 홀수일 때 refpix_a 가 (9*(p1+p2) - (p0+p3)) 과 동일한 것, 또는 상기 베이스 값이 짝수일 때 refpix_a 가 p1 과 동일한 것에 따라 값 refpix_a 를 계산하게 하고; 상기 베이스 값이 홀수일 때 refpix_b 가 p2 와 동일한 것, 또는 상기 베이스 값이 짝수일 때 refpix_b 가 (9*(p1+p2) - (p0+p3)) 과 동일한 것에 따라 값 refpix_b 를 계산하게 하고; 그리고 pred[i][j] = Clip(0, max_pixel_value, Round2( refpix_a * ( 32 - shift ) + refpix_b * shift, 5 )) 에 따라 상기 포지션 (i, j) 에서의 상기 예측 샘플에 대한 값 (pred[i][j]) 을 계산하게 하는명령들을 포함하는, 컴퓨터 판독가능 저장 매체.</claim></claimInfo><claimInfo><claim>17. 제 13 항에 있어서,상기 프로세서로 하여금 상기 현재 블록을 디코딩하기 전에 상기 예측 블록을 사용하여 상기 현재 블록을 인코딩하게 하는 명령들을 더 포함하는, 컴퓨터 판독가능 저장 매체.</claim></claimInfo><claimInfo><claim>18. 비디오 데이터를 디코딩하기 위한 디바이스로서,비디오 데이터의 현재 블록이 각도 인트라-예측 모드를 사용하여 예측될 것임을 결정하는 수단;상기 각도 인트라-예측 모드의 각도에 따라 상기 현재 블록에 대한 예측 블록을 생성하는데 사용될 그리고 업샘플링될 상기 현재 블록에 대한 이웃 샘플들을 결정하는 수단;상기 예측 블록을 생성하는데 사용될 상기 이웃 샘플들을 공동으로 업샘플링하고 그리고 예측된 샘플들에 대한 값들을 생성하는 공식들에 따라 상기 예측 블록의 상기 예측된 샘플들을 계산하는 수단; 및상기 예측 블록을 사용하여 상기 현재 블록을 디코딩하는 수단을 포함하는, 비디오 데이터를 디코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>19. 제 18 항에 있어서,상기 예측 블록의 상기 예측된 샘플들을 계산하는 수단은,상기 현재 블록에 대한 상위 이웃 샘플들을 사용하여 상기 예측된 샘플들의 상부 이웃 경로 계산을 수행하는 수단으로서, 상기 예측 블록의 각각의 샘플에 대해: 인덱스 X 값 (idxX = (j003c#003c#6) + ( i + 1 ) * dx) 을 계산하는 수단으로서, j 는 현재 샘플에 대한 행 포지션 값을 나타내고, i 는 상기 현재 샘플에 대한 열 포지션 값을 나타내고, dx 는 상기 각도 인트라-예측 모드의 각도에 따른 수평 포지션 스칼라 값을 나타내는, 상기 인덱스 X 값을 계산하는 수단; maxBaseX = (w + h - 1) 003c#003c# upsampleAbove 에 따라 최대 베이스 X 값을 계산하는 수단으로서, w 는 상기 현재 블록의 폭을 나타내고, h 는 상기 현재 블록의 높이를 나타내고, upsampleAbove 는 상기 예측 블록을 생성하는데 사용될 그리고 업샘플링될 상기 이웃 샘플들의 결정에 따라 상기 상위 이웃 샘플들이 업샘플링될지 여부를 표시하는 값을 나타내고, '003c#003c#' 는 비트단위 좌측 시프트 연산자를 나타내는, 상기 최대 베이스 X 값을 계산하는 수단; baseX = min (maxBaseX, (idxX 003e#003e# ( 6 - upsampleAbove))) 에 따라 베이스 X 값을 계산하는 수단; 및 shiftX = ( (idxX 003c#003c# upsampleAbove) 003e#003e# 1 ) 0026# 0x1F 에 따라 시프트 X 값을 계산하는 수단으로서, '003e#003e#' 는 비트단위 우측 시프트 연산자를 나타내고 '0026#' 는 비트단위 AND 연산자를 나타내는, 상기 시프트 X 값을 계산하는 수단을 포함하는, 상기 예측된 샘플들의 상부 이웃 경로 계산을 수행하는 수단;상기 현재 블록에 대한 좌측 이웃 샘플들을 사용하여 상기 예측된 샘플들의 좌측 이웃 경로 계산을 수행하는 수단으로서, 상기 예측 블록의 각각의 샘플에 대해: 인덱스 Y 값 (idxY = (i003c#003c#6) + ( j + 1 ) * dy) 을 계산하는 수단으로서, dy 는 상기 각도 인트라-예측 모드의 각도에 따른 수직 포지션 스칼라 값을 나타내는, 상기 인덱스 Y 값을 계산하는 수단; maxBaseY = (w + h - 1) 003c#003c# upsampleLeft 에 따라 최대 베이스 Y 값을 계산하는 수단으로서, upsampleLeft 는 상기 예측 블록을 생성하는데 사용될 그리고 업샘플링될 상기 이웃 샘플들의 결정에 따라 상기 좌측 이웃 샘플들이 업샘플링될지 여부를 표시하는 값을 나타내는, 상기 최대 베이스 Y 값을 계산하는 수단; baseY = min (maxBaseY, (idxY 003e#003e# ( 6 - upsampleLeft))) 에 따라 베이스 Y 값을 계산하는 수단; 및 shiftY = ( (idxY 003c#003c# upsampleLeft) 003e#003e# 1 ) 0026# 0x1F 에 따라 시프트 Y 값을 계산하는 수단으로서, '003e#003e#' 는 비트단위 우측 시프트 연산자를 나타내고 '0026#' 는 비트단위 AND 연산자를 나타내는, 상기 시프트 Y 값을 계산하는 수단을 포함하는, 상기 예측된 샘플들의 좌측 이웃 경로 계산을 수행하는 수단; 및 상기 예측 블록의 각각의 샘플에 대해, base = (baseX 003e#= -(1003c#003c#upsampleAbove)) ? baseX : baseY 에 따라 베이스 포지션 값을 계산하는 수단; 상기 예측 블록의 각각의 샘플에 대해, shift = (baseX 003e#= -(1003c#003c#upsampleAbove)) ? shiftX : shiftY 에 따라 시프트 값을 계산하는 수단; 및 상기 예측 블록의 각각의 샘플에 대해, 베이스 값 및 상기 시프트 값을 사용하여 상기 예측 블록에서 포지션 (i, j) 에서의 예측 샘플에 대한 값을 계산하는 수단을 포함하는, 비디오 데이터를 디코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>20. 제 19 항에 있어서,상기 포지션 (i, j) 에서의 상기 예측 샘플에 대한 값을 계산하는 수단은,상기 포지션 (i, j) 에서의 상기 예측 샘플에 대한 상기 베이스 포지션 값에 따라 4개의 인접한 샘플들을 결정하는 수단; 및상기 4개의 인접한 샘플들을 사용하여 상기 예측 샘플에 대한 값을 계산하는 수단을 포함하는, 비디오 데이터를 디코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>21. 제 20 항에 있어서,상기 4개의 인접한 샘플들을 결정하는 수단은 상기 베이스 포지션 값 마이너스 1 에서의 p1, 베이스 포지션에서의 p2, 상기 베이스 포지션 값 플러스 1 에서의 p3, 및 상기 베이스 포지션 값 플러스 2 에서의 p4 를 포함하는 것으로서 상기 4개의 인접한 샘플들을 결정하는 수단을 포함하고,상기 4개의 인접한 샘플들을 사용하여 상기 예측 샘플에 대한 값을 계산하는 수단은, 베이스 값이 홀수일 때 refpix_a 가 (9*(p1+p2) - (p0+p3)) 과 동일한 것, 또는 상기 베이스 값이 짝수일 때 refpix_a 가 p1 과 동일한 것에 따라 값 refpix_a 를 계산하는 수단; 상기 베이스 값이 홀수일 때 refpix_b 가 p2 와 동일한 것, 또는 상기 베이스 값이 짝수일 때 refpix_b 가 (9*(p1+p2) - (p0+p3)) 과 동일한 것에 따라 값 refpix_b 를 계산하는 수단; 및 pred[i][j] = Clip(0, max_pixel_value, Round2( refpix_a * ( 32 - shift ) + refpix_b * shift, 5 )) 에 따라 상기 포지션 (i, j) 에서의 상기 예측 샘플에 대한 값 (pred[i][j]) 을 계산하는 수단을 포함하는, 비디오 데이터를 디코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>22. 제 18 항에 있어서,상기 현재 블록을 디코딩하기 전에 상기 예측 블록을 사용하여 상기 현재 블록을 인코딩하는 수단을 더 포함하는, 비디오 데이터를 디코딩하기 위한 디바이스.</claim></claimInfo></claimInfoArray><applicantInfoArray><applicantInfo><address>미국 *****-**** 캘리포니아주 샌 디에고 모어하우스 드라이브 ****</address><code>519980804600</code><country>미국</country><engName>Qualcomm Incorporated</engName><name>퀄컴 인코포레이티드</name></applicantInfo></applicantInfoArray><inventorInfoArray><inventorInfo><address>미국 *****-**** 캘리...</address><code> </code><country> </country><engName>AGGARWAL, DHRUV</engName><name>아가르왈 드루브</name></inventorInfo></inventorInfoArray><agentInfoArray><agentInfo><address>서울특별시 강남구 강남대로 **길 **(역삼동, 케이피빌딩)</address><code>920011000013</code><country>대한민국</country><engName>Koreana Patent Firm</engName><name>특허법인코리아나</name></agentInfo></agentInfoArray><priorityInfoArray><priorityInfo><priorityApplicationCountry>미국</priorityApplicationCountry><priorityApplicationDate>2021.02.11</priorityApplicationDate><priorityApplicationNumber>17/174,176</priorityApplicationNumber></priorityInfo></priorityInfoArray><designatedStateInfoArray/><priorArtDocumentsInfoArray/><legalStatusInfoArray><legalStatusInfo><commonCodeName>수리 (Accepted) </commonCodeName><documentEngName>[Patent Application] Document according to the Article 203 of Patent Act</documentEngName><documentName>[특허출원]특허법 제203조에 따른 서면</documentName><receiptDate>2023.08.04</receiptDate><receiptNumber>1-1-2023-0862964-59</receiptNumber></legalStatusInfo><legalStatusInfo><commonCodeName>발송처리완료 (Completion of Transmission) </commonCodeName><documentEngName>Notice of Acceptance</documentEngName><documentName>수리안내서</documentName><receiptDate>2023.09.15</receiptDate><receiptNumber>1-5-2023-0147782-13</receiptNumber></legalStatusInfo><legalStatusInfo><commonCodeName>수리 (Accepted) </commonCodeName><documentEngName> </documentEngName><documentName>[심사청구]심사청구서·우선심사신청서</documentName><receiptDate>2024.12.24</receiptDate><receiptNumber>1-1-2024-1434760-38</receiptNumber></legalStatusInfo><legalStatusInfo><commonCodeName>수리 (Accepted) </commonCodeName><documentEngName> </documentEngName><documentName>[심사유예신청]결정 보류신청서·심사유예신청서</documentName><receiptDate>2024.12.24</receiptDate><receiptNumber>1-1-2024-1434761-84</receiptNumber></legalStatusInfo></legalStatusInfoArray><imagePathInfo><docName>1020237026741.jpg</docName><largePath>http://plus.kipris.or.kr/kiprisplusws/fileToss.jsp?arg=6c650beb4cee9ce4122b704b88878c93537cbed247757550d662a08143a76a484309c6613db3cfaaa385478f174956014d5f329a11bb0003fca61c0cab9a92121608d906ed80efeb</largePath><path>http://plus.kipris.or.kr/kiprisplusws/fileToss.jsp?arg=ed43a0609e94d6e22d01c5c32ba711cf23e458609d65af87b54b227f0971878e5c381b6cd564fd9468924d16a5f7350f5be5f601cb422d9c7f106f84c6c0dce9fb8e8c6d5601b97e</path></imagePathInfo><rndInfoArray/></item></body><count><numOfRows>1</numOfRows><pageNo>1</pageNo><totalCount>1</totalCount></count></response>