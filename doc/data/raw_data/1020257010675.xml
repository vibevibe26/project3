<?xml version="1.0" encoding="UTF-8" standalone="yes"?><response><header><requestMsgID></requestMsgID><responseTime>2025-11-17 17:54:50.5450</responseTime><responseMsgID></responseMsgID><successYN>Y</successYN><resultCode>00</resultCode><resultMsg>NORMAL SERVICE.</resultMsg></header><body><item><biblioSummaryInfoArray><biblioSummaryInfo><applicationDate>2023.10.06</applicationDate><applicationFlag> </applicationFlag><applicationNumber>10-2025-7010675</applicationNumber><claimCount>50</claimCount><examinerName> </examinerName><finalDisposal> </finalDisposal><inventionTitle>선형 회귀-기반 아핀 병합 후보 도출을 위한 비트-길이 제어</inventionTitle><inventionTitleEng>BIT-LENGTH CONTROL FOR LINEAR REGRESSION-BASED AFFINE MERGE CANDIDATE DERIVATION</inventionTitleEng><openDate>2025.06.10</openDate><openNumber>10-2025-0084287</openNumber><originalApplicationDate> </originalApplicationDate><originalApplicationKind>국제출원/신규</originalApplicationKind><originalApplicationNumber> </originalApplicationNumber><originalExaminationRequestDate> </originalExaminationRequestDate><originalExaminationRequestFlag>N</originalExaminationRequestFlag><publicationDate> </publicationDate><publicationNumber> </publicationNumber><registerDate> </registerDate><registerNumber> </registerNumber><registerStatus>공개</registerStatus><translationSubmitDate>2025.04.01</translationSubmitDate></biblioSummaryInfo></biblioSummaryInfoArray><ipcInfoArray><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/54</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/52</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/136</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/149</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/176</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/184</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/43</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/59</ipcNumber></ipcInfo></ipcInfoArray><familyInfoArray><familyInfo/></familyInfoArray><abstractInfoArray><abstractInfo><astrtCont> 비디오 데이터를 코딩하기 위한 예시적인 디바이스는 비디오 데이터를 저장하도록 구성된 메모리, 및 메모리에 통신가능하게 커플링된 하나 이상의 프로세서들을 포함한다. 하나 이상의 프로세서들은 하나 이상의 감소된 비트 길이 입력 변수들을 생성하기 위해 선형 회귀 연산을 위한 하나 이상의 입력 변수들의 비트 길이를 감소시키도록 구성되고, 입력 변수들은 a) 하나 이상의 델타 좌표들, b) 하나 이상의 델타 모션 벡터들, 또는 c) 서브블록들의 수를 나타내는 값 중 적어도 하나를 포함한다. 하나 이상의 프로세서들은 선형 회귀 연산을 수행하고, 하나 이상의 감소된 비트 길이 입력 변수들에 대해 선형 회귀를 수행하는 것에 기초하여 아핀 모션 모델을 도출하도록 구성된다. 하나 이상의 프로세서들은 아핀 모션 모델에 기초하여 비디오 데이터의 현재 블록을 코딩하도록 구성된다. </astrtCont></abstractInfo></abstractInfoArray><internationalInfoArray><internationalInfo><internationOpenDate>2024.04.18</internationOpenDate><internationOpenNumber>WO2024081552</internationOpenNumber><internationalApplicationDate>2023.10.06</internationalApplicationDate><internationalApplicationNumber>PCT/US2023/076189</internationalApplicationNumber></internationalInfo></internationalInfoArray><claimInfoArray><claimInfo><claim>1. 비디오 데이터를 코딩하는 방법으로서,선형 회귀 연산을 위한 입력 변수들의 비트 길이를 제어하는 단계로서, 상기 입력 변수들은 a) 하나 이상의 델타 좌표들, b) 하나 이상의 델타 모션 벡터들, 또는 c) 서브블록들의 수를 나타내는 값 중 적어도 하나를 포함하는, 상기 입력 변수들의 비트 길이를 제어하는 단계;제어된 비트 길이 입력 변수들에 대해 상기 선형 회귀 연산을 수행하는 단계;상기 선형 회귀 연산을 수행하는 것에 기초하여 아핀 모션 모델을 도출하는 단계; 및상기 아핀 모션 모델에 기초하여 상기 비디오 데이터의 현재 블록을 코딩하는 단계를 포함하는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>2. 제1항에 있어서, 상기 입력 변수들의 상기 비트 길이를 제어하는 단계는,하나 이상의 델타 좌표들의 델타 x의 값 또는 델타 y의 값 중 적어도 하나의 비트 길이는 델타 x 델타 y 비트 길이 임계치보다 크다고 결정하는 단계로서, 상기 델타 x 의 값은 상기 현재 블록의 현재 서브블록과 상기 현재 블록의 x 앵커 좌표 사이의 x 방향으로의 거리를 나타내는 값을 포함하고, 상기 델타 y의 값은 상기 현재 서브블록과 상기 현재 블록의 y 앵커 좌표 사이의 y 방향으로의 거리를 나타내는 값을 포함하는, 상기 델타 x 델타 y 비트 길이 임계치보다 크다고 결정하는 단계, 및상기 델타 x의 값 또는 상기 델타 y의 값 중 적어도 하나의 상기 비트 길이가 상기 델타 x 델타 y 비트 길이 임계치보다 큰 것에 기초하여, 상기 선형 회귀 연산에 대한 입력으로서 상기 현재 서브블록을 스킵하는 단계를 포함하는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>3. 제2항에 있어서, 상기 델타 x 델타 y 비트 길이 임계치는 8 비트인, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>4. 제1항에 있어서, 상기 입력 변수들의 상기 비트 길이를 제어하는 단계는,델타 모션 벡터 컴포넌트의 비트 길이가 델타 모션 벡터 비트 길이 임계치보다 크다고 결정하는 단계; 및상기 델타 모션 벡터 컴포넌트의 상기 비트 길이가 상기 델타 모션 벡터 비트 길이 임계치보다 더 큰 것에 기초하여, 상기 선형 회귀 연산에 대한 입력으로서 현재 서브블록을 스킵하는 단계를 포함하는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>5. 제1항에 있어서, 상기 입력 변수들의 상기 비트 길이를 제어하는 단계는,델타 모션 벡터 컴포넌트의 비트 길이가 델타 모션 벡터 비트 길이 임계치보다 크다고 결정하는 단계; 및상기 델타 모션 벡터 컴포넌트의 상기 비트 길이가 상기 델타 모션 벡터 비트 길이 임계치보다 더 큰 것에 기초하여, 상기 델타 모션 벡터 비트 길이 임계치의 길이로 상기 델타 모션 벡터 컴포넌트에 대해 클리핑하는 단계를 포함하는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>6. 제5항에 있어서, 상기 델타 모션 벡터 비트 길이 임계치는 12 비트인, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>7. 제1항에 있어서, 상기 입력 변수들의 상기 비트 길이를 제어하는 단계는,델타 모션 벡터 컴포넌트의 비트 길이가 제1 델타 모션 벡터 비트 길이 임계치보다 큰지 또는 제2 델타 모션 벡터 비트 길이 임계치보다 작은지를 결정하는 단계; 및상기 델타 모션 벡터 컴포넌트의 상기 비트 길이가 상기 제1 델타 모션 벡터 비트 길이 임계치보다 크거나 또는 상기 제2 델타 모션 벡터 비트 길이 임계치보다 작다는 결정에 기초하여, 상기 선형 회귀 연산에 대한 입력으로서 상기 델타 모션 벡터 컴포넌트 대신에 대체 델타 모션 벡터 컴포넌트를 사용하는 단계를 포함하고, 상기 대체 델타 모션 벡터 컴포넌트는 상기 델타 모션 벡터 컴포넌트보다 작은 비트 길이를 갖는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>8. 제1항에 있어서, 상기 입력 변수들의 상기 비트 길이를 제어하는 단계는 상기 선형 회귀 연산에서 사용되는 서브블록들의 수를 나타내는 값의 비트 길이를 미리 결정된 비트 길이로 감소시키는 단계를 포함하는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>9. 제8항에 있어서, 상기 미리 결정된 비트 길이는 8 비트인, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>10. 제8항에 있어서, 상기 입력 변수들의 상기 비트 길이를 제어하는 단계는 상기 선형 회귀 연산에 사용하기 위해 상기 비디오 데이터의 현재 블록의 서브블록들의 서브세트를 선택하는 단계를 포함하고, 상기 서브블록들의 서브세트는 상기 현재 블록 내의 서브블록들의 총 수보다 작고, 상기 방법은템플릿 영역 내의 서브블록들의 제1 수를 결정하는 단계; 및비인접 아핀 블록 내의 서브블록들의 제2 수를 결정하는 단계를 더 포함하고, 상기 비인접 아핀 블록은 상기 현재 블록에 인접하지 않고 아핀 모드를 사용하여 코딩되는 상기 비디오 데이터의 블록인, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>11. 제10항에 있어서, 상기 제1 수는 M/2를 포함하고, 상기 제2 수는 M/2를 포함하며, 여기서 M은 상기 선형 회귀 연산에 사용되는 상기 서브블록들의 수를 나타내는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>12. 제10항에 있어서, 상기 제1 수는 M/4를 포함하고, 상기 제2 수는 M-M/4를 포함하며, 여기서 M은 상기 선형 회귀 연산에 사용되는 상기 서브블록들의 수를 나타내는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>13. 제10항에 있어서,상기 템플릿 영역을 위해 허용 서브블록들의 최대 수, T를 결정하는 단계; 및템플릿 영역으로부터 이용가능한 서브-블록들의 수, T'를 결정하는 단계를 더 포함하고,상기 제1 수, S는 min(T, T′)과 같고 상기 제2 수는 M - S과 같고, 여기서 M은 상기 선형 회귀 연산에 사용되는 상기 서브블록들의 수를 나타내는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>14. 제10항에 있어서, 상기 서브블록들의 서브세트를 선택하는 단계는 스캔 순서로 서브-블록들을 선택하는 단계를 포함하는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>15. 제10항에 있어서, 상기 서브블록들의 서브세트를 선택하는 단계는 미리 결정된 서브-샘플 비를 사용하여 서브-샘플링하는 단계를 포함하는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>16. 제10항에 있어서, 상기 서브블록들의 서브세트를 선택하는 단계는,미리 결정된 서브-샘플 비를 이용하여 상기 템플릿 영역 내의 서브블록들을 서브-샘플링하는 단계; 및선택된 서브-블록들의 수가 상기 제2 수와 동일할 때까지 스캔 순서로 비인접 아핀 서브-블록들을 선택하는 단계를 포함하는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>17. 제10항에 있어서, 상기 서브블록들의 서브세트를 선택하는 단계는,상기 현재 블록의 현재 CU의 높이 또는 폭 중 적어도 하나가 256과 동일한지 여부를 결정하는 단계;상기 현재 CU의 상기 높이 또는 상기 폭 중 적어도 하나가 256과 동일하다는 결정에 기초하여, 서브-샘플링 비가 ½인 상기 템플릿 영역의 수평 템플릿 행 스캔 또는 상기 템플릿 영역의 수직 템플릿 열 스캔 중 적어도 하나에서 서브-샘플링을 수행하는 단계;상기 템플릿 영역의 서브블록들의 총 수, T를 결정하는 단계;이용 가능한 비인접 아핀 서브블록들의 총 수가 255 - T보다 큰지 여부를 결정하는 단계; 및상기 이용가능한 비인접 아핀 서브블록들의 총 수가 255 - T보다 크다는 결정에 기초하여, 상기 선형 회귀 연산을 위한 입력으로서 래스터 스캔 순서로 제1의 255 - T개 이용가능한 비인접 아핀 서브블록들을 사용하는 단계를 포함하는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>18. 제1항에 있어서, 하나 이상의 선형 회귀 연산 출력 파라미터들의 비트 길이를 제한하는 단계를 더 포함하는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>19. 제18항에 있어서, 하나 이상의 선형 회귀 연산 출력 파라미터들의 비트 길이를 제한하는 단계는 상기 하나 이상의 선형 회귀 연산 출력 파라미터들을 클리핑하는 단계를 포함하는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>20. 제19항에 있어서, 상기 하나 이상의 선형 회귀 연산 출력 파라미터들을 클리핑하는 단계는 상기 하나 이상의 선형 회귀 연산 출력 파라미터들의 각각을 동일한 수의 비트들로 클리핑하는 단계를 포함하는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>21. 제19항에 있어서, 상기 하나 이상의 선형 회귀 연산 출력 파라미터들을 클리핑하는 단계는 상기 하나 이상의 선형 회귀 연산 출력 파라미터들 중 적어도 하나의 파라미터를 상기 하나 이상의 선형 회귀 연산 출력 파라미터들 중 다른 파라미터들과 상이한 수의 비트들로 클리핑하는 단계를 포함하는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>22. 제21항에 있어서, 상기 하나 이상의 선형 회귀 연산 출력 파라미터들 중 적어도 하나의 파라미터를 상기 하나 이상의 선형 회귀 연산 출력 파라미터들 중 다른 파라미터들과 상이한 수의 비트들로 클리핑하는 단계는,제1 선형 회귀 연산 출력 파라미터를 [ -(1 003c#003c# (M + N)), (1 003c#003c# (M + N)) - 1]의 범위로 클리핑하는 단계; 및제2 선형 회귀 연산 출력 파라미터 및 제3 선형 회귀 연산 출력 파라미터를 [ -(1 003c#003c# (M - 1)), (1 003c#003c# (M - 1)) - 1의 범위로 클리핑하는 단계를 포함하고,M = 12 및 N = 8인, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>23. 제1항에 있어서, 상기 아핀 모션 모델에 기초하여 아핀 모션 후보를 결정하는 단계를 더 포함하는, 비디오 데이터를 코딩하는 방법.</claim></claimInfo><claimInfo><claim>24. 비디오 데이터를 코딩하기 위한 디바이스로서,상기 비디오 데이터를 저장하도록 구성된 메모리; 및상기 메모리에 통신가능하게 커플링된 하나 이상의 프로세서들을 포함하고, 상기 하나 이상의 프로세서들은, 선형 회귀 연산을 위한 입력 변수들의 비트 길이를 제어하는 것으로서, 상기 입력 변수들은 a) 하나 이상의 델타 좌표들, b) 하나 이상의 델타 모션 벡터들, 또는 c) 서브블록들의 수를 나타내는 값 중 적어도 하나를 포함하는, 상기 입력 변수들의 비트 길이를 제어하고; 제어된 비트 길이 입력 변수들에 대해 상기 선형 회귀 연산을 수행하고; 상기 선형 회귀 연산을 수행하는 것에 기초하여 아핀 모션 모델을 도출하고; 상기 아핀 모션 모델에 기초하여 상기 비디오 데이터의 현재 블록을 코딩하도록 구성되는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>25. 제24항에 있어서, 상기 입력 변수들의 상기 비트 길이를 제어하는 것의 일부로서, 상기 하나 이상의 프로세서들은,하나 이상의 델타 좌표들의 델타 x의 값 또는 델타 y의 값 중 적어도 하나의 비트 길이는 델타 x 델타 y 비트 길이 임계치보다 크다고 결정하는 것으로서, 상기 델타 x의 값은 상기 현재 블록의 현재 서브블록과 상기 현재 블록의 x 앵커 좌표 사이의 x 방향으로의 거리를 나타내는 값을 포함하고, 상기 델타 y의 값은 상기 현재 서브블록과 상기 현재 블록의 y 앵커 좌표 사이의 y 방향으로의 거리를 나타내는 값을 포함하는, 상기 델타 x 델타 y 비트 길이 임계치보다 크다고 결정하고;상기 델타 x의 값 또는 상기 델타 y의 값 중 적어도 하나의 상기 비트 길이가 상기 델타 x 델타 y 비트 길이 임계치보다 큰 것에 기초하여, 상기 선형 회귀 연산에 대한 입력으로서 상기 현재 서브블록을 스킵하도록 구성되는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>26. 제25항에 있어서, 상기 델타 x 델타 y 비트 길이 임계치는 8 비트인, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>27. 제24항에 있어서, 상기 입력 변수들의 상기 비트 길이를 제어하는 것의 일부로서, 상기 하나 이상의 프로세서들은,델타 모션 벡터 컴포넌트의 비트 길이가 델타 모션 벡터 비트 길이 임계치보다 크다고 결정하고;상기 델타 모션 벡터 컴포넌트의 상기 비트 길이가 상기 델타 모션 벡터 비트 길이 임계치보다 더 큰 것에 기초하여, 상기 선형 회귀 연산에 대한 입력으로 현재 서브블록을 스킵하도록 구성되는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>28. 제24항에 있어서, 상기 입력 변수들의 상기 비트 길이를 제어하는 것의 일부로서, 상기 하나 이상의 프로세서들은,델타 모션 벡터 컴포넌트의 비트 길이가 델타 모션 벡터 비트 길이 임계치보다 크다고 결정하고;상기 델타 모션 벡터 컴포넌트의 상기 비트 길이가 상기 델타 모션 벡터 비트 길이 임계치보다 더 큰 것에 기초하여, 상기 델타 모션 벡터 비트 길이 임계치의 길이로 상기 델타 모션 벡터 컴포넌트에 대해 클리핑하도록 구성되는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>29. 제28항에 있어서, 상기 델타 모션 벡터 비트 길이 임계치는 12 비트인, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>30. 제24항에 있어서, 상기 입력 변수들의 상기 비트 길이를 제어하는 것의 일부로서, 상기 하나 이상의 프로세서들은,델타 모션 벡터 컴포넌트의 비트 길이가 제1 델타 모션 벡터 비트 길이 임계치보다 큰지 또는 제2 델타 모션 벡터 비트 길이 임계치보다 작은지를 결정하고;상기 델타 모션 벡터 컴포넌트의 상기 비트 길이가 상기 제1 델타 모션 벡터 비트 길이 임계치보다 크거나 또는 상기 제2 델타 모션 벡터 비트 길이 임계치보다 작다는 결정에 기초하여, 상기 선형 회귀 연산에 대한 입력으로서 상기 델타 모션 벡터 컴포넌트 대신에 대체 델타 모션 벡터 컴포넌트를 사용하도록 구성되고, 상기 대체 델타 모션 벡터 컴포넌트는 상기 델타 모션 벡터 컴포넌트보다 작은 비트 길이를 갖는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>31. 제24항에 있어서, 상기 입력 변수들의 상기 비트 길이를 제어하는 것의 일부로서, 상기 하나 이상의 프로세서들은 상기 선형 회귀 연산에서 사용되는 서브블록들의 수를 나타내는 값의 비트 길이를 미리 결정된 비트 길이로 감소시키도록 구성되는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>32. 제31항에 있어서, 상기 미리 결정된 비트 길이는 8 비트인, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>33. 제31항에 있어서, 상기 입력 변수들의 상기 비트 길이를 제어하는 것의 일부로서, 상기 하나 이상의 프로세서들은 상기 선형 회귀 연산을 위한 상기 하나 이상의 입력 변수들에 대한 입력으로서 사용하기 위해 상기 비디오 데이터의 현재 블록의 서브블록들의 서브세트를 선택하도록 구성되며, 상기 서브블록들의 서브세트는 상기 현재 블록 내의 서브블록들의 총 수보다 작고, 상기 하나 이상의 프로세서들은 템플릿 영역 내의 서브블록들의 제1 수를 결정하고; 비인접 아핀 블록 내의 서브블록들의 제2 수를 결정하도록 추가로 구성되고, 상기 비인접 아핀 블록은 상기 현재 블록에 인접하지 않고 아핀 모드를 사용하여 코딩되는 상기 비디오 데이터의 블록인, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>34. 제33항에 있어서, 상기 제1 수는 M/2를 포함하고, 상기 제2 수는 M/2를 포함하며, 여기서 M은 상기 선형 회귀 연산에 사용되는 상기 서브블록들의 수를 나타내는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>35. 제33항에 있어서, 상기 제1 수는 M/4를 포함하고, 상기 제2 수는 M-M/4를 포함하며, 여기서 M은 상기 선형 회귀 연산에 사용되는 상기 서브블록들의 수를 나타내는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>36. 제33항에 있어서, 상기 하나 이상의 프로세서들은,상기 템플릿 영역을 위한 허용 서브-블록들의 최대 수, T를 결정하고;템플릿 영역으로부터 이용가능한 서브-블록들의 수, T'를 결정하도록 추가로 구성되고,상기 제1 수, S는 min(T, T′)과 같고 상기 제2 수는 M - S과 같고, 여기서 M은 상기 선형 회귀 연산에 사용되는 상기 서브블록들의 수를 나타내는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>37. 제33항에 있어서, 상기 서브블록들의 서브세트를 선택하는 것의 일부로서, 상기 하나 이상의 프로세서들은 스캔 순서에서 서브-블록들을 선택하도록 구성된, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>38. 제33항에 있어서, 상기 서브블록들의 서브세트를 선택하는 것의 일부로서, 상기 하나 이상의 프로세서들은 미리 결정된 서브-샘플 비를 사용하여 서브-샘플링하도록 구성되는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>39. 제33항에 있어서, 상기 서브블록들의 서브세트를 선택하는 것의 일부로서, 상기 하나 이상의 프로세서들은,미리 결정된 서브-샘플 비를 사용하여 상기 템플릿 영역 내의 서브블록들을 서브-샘플링하고;선택된 서브-블록들의 수가 상기 제2 수와 동일할 때까지 스캔 순서로 비인접 아핀 서브-블록들을 선택하도록 구성되는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>40. 제33항에 있어서, 상기 서브블록들의 서브세트를 선택하는 것의 일부로서, 상기 하나 이상의 프로세서들은,상기 현재 블록의 현재 CU의 높이 또는 폭 중 적어도 하나가 256과 동일한지 여부를 결정하고;상기 현재 CU의 상기 높이 또는 상기 폭 중 적어도 하나가 256과 동일하다는 결정에 기초하여, 서브-샘플링 비가 ½인 상기 템플릿 영역의 수평 템플릿 행 스캔 또는 상기 템플릿 영역의 수직 템플릿 열 스캔 중 적어도 하나에서 서브-샘플링을 수행하고;상기 템플릿 영역의 서브블록들의 총 수, T를 결정하고;이용 가능한 비인접 아핀 서브블록들의 총 수가 255 - T보다 큰지 여부를 결정하고;상기 이용가능한 비인접 아핀 서브블록들의 총 수가 255 - T보다 크다는 결정에 기초하여, 상기 선형 회귀 연산을 위한 입력으로서 래스터 스캔 순서로 제1의 255 - T개 이용가능한 비인접 아핀 서브블록들을 사용하도록 구성되는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>41. 제24항에 있어서, 상기 하나 이상의 프로세서들은 하나 이상의 선형 회귀 연산 출력 파라미터들의 비트 길이를 제한하도록 추가로 구성되는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>42. 제41항에 있어서, 하나 이상의 선형 회귀 연산 출력 파라미터들의 비트 길이를 제한하는 것의 일부로서, 상기 하나 이상의 프로세서들은 상기 하나 이상의 선형 회귀 연산 출력 파라미터들을 클리핑하도록 구성되는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>43. 제42항에 있어서, 상기 하나 이상의 선형 회귀 연산 출력 파라미터들을 클리핑하는 것의 일부로서, 상기 하나 이상의 프로세서들은 상기 하나 이상의 선형 회귀 연산 출력 파라미터들의 각각을 동일한 수의 비트들로 클리핑하도록 구성되는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>44. 제42항에 있어서, 상기 하나 이상의 선형 회귀 연산 출력 파라미터들을 클리핑하는 것의 일부로서, 상기 하나 이상의 프로세서들은 상기 하나 이상의 선형 회귀 연산 출력 파라미터들 중 적어도 하나의 파라미터를 상기 하나 이상의 선형 회귀 연산 출력 파라미터들 중 다른 파라미터들과 상이한 수의 비트들로 클리핑하도록 구성되는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>45. 제44항에 있어서, 상기 하나 이상의 선형 회귀 연산 출력 파라미터들 중 상기 적어도 하나의 파라미터를 상기 하나 이상의 선형 회귀 연산 출력 파라미터들 중 다른 파라미터들과 상이한 수의 비트들로 클리핑하는 것의 일부로서, 상기 하나 이상의 프로세서들은제1 선형 회귀 연산 출력 파라미터를 [ -(1 003c#003c# (M + N)), (1 003c#003c# (M + N)) - 1]의 범위로 클리핑하고; 그리고제2 선형 회귀 연산 출력 파라미터 및 제3 선형 회귀 연산 출력 파라미터를 [ -(1 003c#003c# (M - 1)), (1 003c#003c# (M - 1)) - 1의 범위로 클리핑하도록 구성되고,M = 12 및 N = 8인, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>46. 제24항에 있어서, 상기 하나 이상의 프로세서들은, 상기 아핀 모션 모델에 기초하여 아핀 모션 후보를 결정하도록 추가로 구성되는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>47. 제24항에 있어서, 디코딩된 비디오 데이터를 디스플레이하도록 구성된 디스플레이를 더 포함하는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>48. 제24항에 있어서, 상기 디바이스는 카메라, 컴퓨터, 모바일 디바이스, 브로드캐스트 수신기 디바이스, 또는 셋톱 박스 중 하나 이상을 포함하는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo><claimInfo><claim>49. 명령들이 저장된 비일시적 컴퓨터 판독가능 저장 매체로서,상기 명령들은, 실행될 때, 하나 이상의 프로세서들로 하여금,하나 이상의 감소된 비트 길이 입력 변수들을 생성하기 위해 선형 회귀 연산을 위한 입력 변수들의 비트 길이를 제어하게 하는 것으로서, 상기 입력 변수들은 a) 하나 이상의 델타 좌표들, b) 하나 이상의 델타 모션 벡터들, 또는 c) 서브블록들의 수를 나타내는 값 중 적어도 하나를 포함하는, 상기 입력 변수들의 비트 길이를 제어하게 하고;제어된 비트 길이 입력 변수들에 대해 상기 선형 회귀 연산을 수행하게 하고;상기 선형 회귀 연산을 수행하는 것에 기초하여 아핀 모션 모델을 도출하게 하고;상기 아핀 모션 모델에 기초하여 상기 비디오 데이터의 현재 블록을 코딩하게 하는, 비일시적 컴퓨터 판독가능 저장 매체.</claim></claimInfo><claimInfo><claim>50. 비디오 데이터를 코딩하기 위한 디바이스로서,하나 이상의 감소된 비트 길이 입력 변수들을 생성하기 위해 선형 회귀 연산을 위한 입력 변수들의 비트 길이를 제어하기 위한 수단으로서, 상기 하나 이상의 입력 변수들은 a) 하나 이상의 델타 좌표들, b) 하나 이상의 델타 모션 벡터들, 또는 c) 서브블록들의 수를 나타내는 값 중 적어도 하나를 포함하는, 상기 입력 변수들의 비트 길이를 제어하기 위한 수단;제어된 비트 길이 입력 변수들에 대해 상기 선형 회귀 연산을 수행하기 위한 수단;상기 선형 회귀 연산을 수행하는 것에 기초하여 아핀 모션 모델을 도출하기 위한 수단; 및상기 아핀 모션 모델에 기초하여 상기 비디오 데이터의 현재 블록을 코딩하기 위한 수단을 포함하는, 비디오 데이터를 코딩하기 위한 디바이스.</claim></claimInfo></claimInfoArray><applicantInfoArray><applicantInfo><address>미국 *****-**** 캘리포니아주 샌 디에고 모어하우스 드라이브 ****</address><code>519980804600</code><country>미국</country><engName>Qualcomm Incorporated</engName><name>퀄컴 인코포레이티드</name></applicantInfo></applicantInfoArray><inventorInfoArray><inventorInfo><address>미국 *****-**** 캘리...</address><code> </code><country>중국</country><engName>ZHANG, YAN</engName><name>장 얀</name></inventorInfo><inventorInfo><address>미국 *****-**** 캘리...</address><code> </code><country>중국</country><engName>HUANG, HAN</engName><name>황 한</name></inventorInfo><inventorInfo><address>미국 *****-**** 캘리...</address><code> </code><country>미국</country><engName>SEREGIN, VADIM</engName><name>세레긴 바딤</name></inventorInfo><inventorInfo><address>미국 *****-**** 캘리...</address><code> </code><country>미국</country><engName>KARCZEWICZ, MARTA</engName><name>카르체비츠 마르타</name></inventorInfo></inventorInfoArray><agentInfoArray><agentInfo><address>서울특별시 강남구 강남대로 **길 **(역삼동, 케이피빌딩)</address><code>920011000013</code><country>대한민국</country><engName>Koreana Patent Firm</engName><name>특허법인코리아나</name></agentInfo></agentInfoArray><priorityInfoArray><priorityInfo><priorityApplicationCountry>미국</priorityApplicationCountry><priorityApplicationDate>2022.10.14</priorityApplicationDate><priorityApplicationNumber>63/379,555</priorityApplicationNumber></priorityInfo><priorityInfo><priorityApplicationCountry>미국</priorityApplicationCountry><priorityApplicationDate>2023.10.05</priorityApplicationDate><priorityApplicationNumber>18/481,590</priorityApplicationNumber></priorityInfo></priorityInfoArray><designatedStateInfoArray/><priorArtDocumentsInfoArray/><legalStatusInfoArray><legalStatusInfo><commonCodeName>수리 (Accepted) </commonCodeName><documentEngName>[Patent Application] Document according to the Article 203 of Patent Act</documentEngName><documentName>[특허출원]특허법 제203조에 따른 서면</documentName><receiptDate>2025.04.01</receiptDate><receiptNumber>1-1-2025-0367110-32</receiptNumber></legalStatusInfo><legalStatusInfo><commonCodeName>발송처리완료 (Completion of Transmission) </commonCodeName><documentEngName>Notice of Acceptance</documentEngName><documentName>수리안내서</documentName><receiptDate>2025.05.19</receiptDate><receiptNumber>1-5-2025-0083116-15</receiptNumber></legalStatusInfo></legalStatusInfoArray><imagePathInfo><docName>1020257010675.jpg</docName><largePath>http://plus.kipris.or.kr/kiprisplusws/fileToss.jsp?arg=6c650beb4cee9ce4122b704b88878c93b5315f492ca7c5e900291b51575676827e6ef20af7808d89009efdef7f672988af43f13c2b31245d3d156b04c502b1f712e67ba9cc1157ca</largePath><path>http://plus.kipris.or.kr/kiprisplusws/fileToss.jsp?arg=ed43a0609e94d6e22d01c5c32ba711cf40a4916ea9f0c7cb4bad33f1903bee06283dd988b332eddf4f89997893e101c8aa10e0d7b7cce0e71280be90fdf312808ece6cbcc3757b89</path></imagePathInfo><rndInfoArray/></item></body><count><numOfRows>1</numOfRows><pageNo>1</pageNo><totalCount>1</totalCount></count></response>