<?xml version="1.0" encoding="UTF-8" standalone="yes"?><response><header><requestMsgID></requestMsgID><responseTime>2025-11-17 18:40:08.408</responseTime><responseMsgID></responseMsgID><successYN>Y</successYN><resultCode>00</resultCode><resultMsg>NORMAL SERVICE.</resultMsg></header><body><item><biblioSummaryInfoArray><biblioSummaryInfo><applicationDate>2023.01.20</applicationDate><applicationFlag> </applicationFlag><applicationNumber>10-2025-7027646</applicationNumber><claimCount>91</claimCount><examinerName> </examinerName><finalDisposal> </finalDisposal><inventionTitle>인코딩/디코딩 방법 및 장치, 인코더, 디코더, 비트스트림, 저장매체</inventionTitle><inventionTitleEng>ENCODING METHOD AND APPARATUS, DECODING METHOD AND APPARATUS, ENCODER, DECODER, CODE STREAM, AND STORAGE MEDIUM</inventionTitleEng><openDate>2025.09.16</openDate><openNumber>10-2025-0136884</openNumber><originalApplicationDate> </originalApplicationDate><originalApplicationKind>국제출원/신규</originalApplicationKind><originalApplicationNumber> </originalApplicationNumber><originalExaminationRequestDate> </originalExaminationRequestDate><originalExaminationRequestFlag>N</originalExaminationRequestFlag><publicationDate> </publicationDate><publicationNumber> </publicationNumber><registerDate> </registerDate><registerNumber> </registerNumber><registerStatus>공개</registerStatus><translationSubmitDate>2025.08.19</translationSubmitDate></biblioSummaryInfo></biblioSummaryInfoArray><ipcInfoArray><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/105</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/176</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/593</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/132</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/137</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/157</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/70</ipcNumber></ipcInfo></ipcInfoArray><familyInfoArray><familyInfo/></familyInfoArray><abstractInfoArray><abstractInfo><astrtCont> 본 출원의 실시예는 인코딩/디코딩 방법 및 장치, 인코더, 디코더, 비트스트림, 저장매체를 제공하다. 상기 인코딩 방법은 인코더에 적용되며, 당해 방법은, 현재 블록의 템플릿과 상기 현재 블록의 템플릿의 하나 또는 복수의 예측 템플릿을 결정하는 단계; 상기 현재 블록의 템플릿과 상기 하나 또는 복수의 예측 템플릿을 기반으로 상기 하나 또는 복수의 예측 템플릿의 가중치를 결정하는 단계; 상기 현재 블록의 예측 파라미터를 기반으로 상기 현재 블록의 하나 또는 복수의 제1 예측 블록을 결정하는 단계; 및 상기 하나 또는 복수의 예측 템플릿의 가중치를 기반으로 상기 하나 또는 복수의 제1 예측 블록에 대해 융합을 수행하여, 상기 현재 블록의 제2 예측 블록을 얻는 단계를 포함한다. </astrtCont></abstractInfo></abstractInfoArray><internationalInfoArray><internationalInfo><internationOpenDate>2024.07.25</internationOpenDate><internationOpenNumber>WO2024152384</internationOpenNumber><internationalApplicationDate>2023.01.20</internationalApplicationDate><internationalApplicationNumber>PCT/CN2023/073453</internationalApplicationNumber></internationalInfo></internationalInfoArray><claimInfoArray><claimInfo><claim>1. 인코더에 적용되는 인코딩 방법으로서,현재 블록의 템플릿과 상기 현재 블록의 템플릿의 하나 또는 복수의 예측 템플릿을 결정하는 단계;상기 현재 블록의 템플릿과 상기 하나 또는 복수의 예측 템플릿을 기반으로 상기 하나 또는 복수의 예측 템플릿의 가중치를 결정하는 단계;상기 현재 블록의 예측 파라미터를 기반으로 상기 현재 블록의 하나 또는 복수의 제1 예측 블록을 결정하는 단계; 및상기 하나 또는 복수의 예측 템플릿의 가중치를 기반으로 상기 하나 또는 복수의 제1 예측 블록에 대해 융합을 수행하여, 상기 현재 블록의 제2 예측 블록을 얻는 단계를 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>2. 제1항에 있어서,상기 예측 파라미터가 지시하는 인트라 예측 모드를 기반으로 상기 현재 블록의 제1 예측 블록을 결정하는 방법.</claim></claimInfo><claimInfo><claim>3. 제1항 또는 제2항에 있어서,상기 예측 파라미터가 지시하는 상기 현재 블록의 모션 파라미터 또는 BV를 기반으로 상기 현재 블록의 제1 예측 블록을 결정하는 방법.</claim></claimInfo><claimInfo><claim>4. 제3항에 있어서,상기 모션 파라미터는 MV 및 참조 이미지 인덱스 중 적어도 하나의 파라미터를 포함하는 방법.</claim></claimInfo><claimInfo><claim>5. 제1항 내지 제4항 중 어느 한 항에 있어서,상기 현재 블록의 예측 파라미터와 상기 현재 블록의 템플릿의 예측 파라미터는 동일한 방법.</claim></claimInfo><claimInfo><claim>6. 제1항에 있어서,상기 현재 블록의 템플릿의 예측 템플릿을 결정하는 것은,상기 현재 블록의 템플릿의 샘플에 대해 HoG 계산을 수행하여 해당 샘플의 그래디언트 방향과 그래디언트 크기를 얻는 단계;상기 그래디언트 방향과 그래디언트 크기를 기반으로 각도 모드를 결정하는 단계; 및상기 각도 모드를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하여 상기 예측 템플릿을 얻는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>7. 제6항에 있어서,상기의, 상기 그래디언트 방향과 그래디언트 크기를 기반으로 각도 모드를 결정하는 단계는,상기 그래디언트 방향을 미리 정의된 후보 각도 모드로 전환하는 단계; 및상기 그래디언트 크기를 기반으로, 전환된 후보 각도 모드에서 상기 각도 모드를 결정하는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>8. 제7항에 있어서,상기의, 상기 그래디언트 크기를 기반으로 각도 모드를 결정하는 단계는,N개의 가장 큰 그래디언트 크기에 대응하는 후보 각도 모드를 기반으로 N개의 상기 각도 모드를 얻는 단계; 제1 임계값보다 크거나 같은 그래디언트 크기에 대응하는 후보 각도 모드를 기반으로 하나 또는 복수의 상기 각도 모드를 얻는 단계; 및 적어도 하나의 제1 그래디언트 크기와의 차이값이 제2 임계값보다 작거나 같은 제2 그래디언트 크기에 대응하는 후보 각도 모드를 기반으로 하나 또는 복수의 상기 각도 모드를 얻는 단계 중 적어도 하나를 포함하는 방법.</claim></claimInfo><claimInfo><claim>9. 제8항에 있어서,상기 적어도 하나의 제1 그래디언트 크기의 값은 상기 제2 그래디언트 크기와 인접한 방법.</claim></claimInfo><claimInfo><claim>10. 제1항에 있어서,상기 현재 블록의 템플릿의 예측 템플릿을 결정하는 것은,모드 리스트 중의 후보 예측 모드를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하여 후보 예측 템플릿을 얻는 단계; 및상기 후보 예측 템플릿과 상기 현재 블록의 템플릿 사이의 샘플 값 오차를 기반으로 상기 예측 템플릿을 얻는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>11. 제10항에 있어서,상기의, 상기 후보 예측 템플릿과 상기 현재 블록의 템플릿 사이의 샘플 값 오차를 기반으로 상기 예측 템플릿을 얻는 단계는,N개의 가장 작은 샘플 값 오차에 대응하는 후보 예측 템플릿을 기반으로 N개의 상기 예측 템플릿을 얻는 단계; 또는,제3 임계값보다 작거나 같은 샘플 값 오차에 대응하는 후보 예측 템플릿을 기반으로 하나 또는 복수의 상기 예측 템플릿을 얻는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>12. 제10항 또는 제11항에 있어서,상기 샘플 값 오차의 유형은 적어도 SATD, SAD, MAD, MAE, NCC, MSE, SSE 중 하나인 방법.</claim></claimInfo><claimInfo><claim>13. 제10항에 있어서,상기 모드 리스트 중의 후보 예측 모드는,제6항 내지 제9항 중 어느 한 항에 따른 단계를 통해 얻은 상기 각도 모드;MPM 리스트 중의 예측 모드;Planar 모드가 삭제된 MPM 리스트 중의 예측 모드;상기 MPM 리스트 중 각도가 제4 임계값보다 크거나 같은 각도 모드에 대해 확장을 수행하여 얻은 각도 모드; 및상기 MPM 리스트 중 각도 모드가 제5 임계값보다 작거나 같은 각도 모드에 대해 확장을 수행하여 얻은 각도 모드 중 적어도 하나를 포함하는 방법.</claim></claimInfo><claimInfo><claim>14. 제13항에 있어서,상기 MPM 리스트에서, DC 모드는 상기 현재 블록의 인접 블록을 기반으로 구성된 각도 모드 이후 또는 이전에 위치하는 방법.</claim></claimInfo><claimInfo><claim>15. 제13항에 있어서,상기 모드 리스트에서, 상기 N개의 각도 모드는 상기 현재 블록의 인접 블록을 가반으로 구성된 각도 모드 이후 또는 이전에 위치하는 방법.</claim></claimInfo><claimInfo><claim>16. 제10항 내지 제15항 중 어느 한 항에 있어서,상기의, 모드 리스트 중의 후보 예측 모드를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하여 후보 예측 템플릿을 얻는 단계는,상기 현재 블록의 템플릿의 참조 영역의 샘플 값과 상기 후보 예측 모드를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하여 후보 예측 템플릿을 얻는 단계를 포함하되, 상기 참조 영역은 상기 현재 블록의 템플릿의 비인접 영역 및/또는 인접 영역을 포함하는 방법.</claim></claimInfo><claimInfo><claim>17. 제16항에 있어서,상기 참조 영역은 상기 현재 블록의 템플릿의 좌상측 영역, 상측 영역, 우상측 영역, 좌측 영역 및/또는 좌하측 영역을 포함하는 방법.</claim></claimInfo><claimInfo><claim>18. 제10항 내지 제15항 중 어느 한 항에 있어서,상기의, 모드 리스트 중의 후보 예측 모드를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하여 후보 예측 템플릿을 얻는 단계는,상기 모드 리스트 중의 후보 예측 모드와 상기 현재 블록의 템플릿의 참조 라인 리스트 중의 참조 라인을 조합하여 조합 리스트를 얻는 단계; 및조합 리스트 중 조합이 지시하는 후보 예측 모드와 참조 라인을 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하여 후보 예측 템플릿을 얻는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>19. 제18항에 있어서,상기 참조 라인 리스트에 포함된 참조 라인 인덱스는 {1,3,5,7,12} 또는 {1,4,5,7,10,12} 또는 {1,2,3,7,10,11}인 방법.</claim></claimInfo><claimInfo><claim>20. 제1항 내지 제19항 중 어느 한 항에 있어서,상기 현재 블록의 템플릿의 예측 템플릿을 결정하는 것은,적어도 하나의 후보 MV를 결정하는 단계; 및상기 후보 MV와 상기 현재 블록의 참조 이미지를 기반으로 상기 현재 블록의 템플릿에 대해 모션 보상을 수행하여 상기 예측 템플릿을 얻는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>21. 제20항에 있어서,상기 현재 블록의 참조 이미지는 상기 현재 블록의 순방향 참조 이미지 또는 역방향 참조 이미지인 방법.</claim></claimInfo><claimInfo><claim>22. 제20항에 있어서,상기의, 적어도 하나의 후보 MV를 결정하는 단계는,Merge 후보 리스트 또는 AMVP 후보 리스트를 기반으로 적어도 하나의 후보 MV를 얻는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>23. 제22항에 있어서,상기의, Merge 후보 리스트 또는 AMVP 후보 리스트를 기반으로 적어도 하나의 후보 MV를 얻는 단계는,상기 Merge 후보 리스트 또는 AMVP 후보 리스트 중 상위 N개의 후보 MV를 획득하는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>24. 제23항에 있어서,상기 Merge 후보 리스트 또는 AMVP 후보 리스트 중의 후보 MV는 템플릿 매칭, DMVR 및/또는 Multipass DMVR을 통해 리파인된 MV이며; 및/또는, 상기 Merge 후보 리스트 또는 AMVP 후보 리스트 중의 후보 MV는 원본 후보 리스트에서 약속된 순서에 따라 정렬된 후보 MV인 방법.</claim></claimInfo><claimInfo><claim>25. 제1항 내지 제24항 중 어느 한 항에 있어서,상기 현재 블록의 템플릿의 예측 템플릿을 결정하는 것은,적어도 하나의 후보 BV를 결정하는 단계; 및상기 후보 BV, 상기 현재 블록 및 현재 이미지를 기반으로 상기 현재 블록의 템플릿의 예측 템플릿을 결정하는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>26. 제25항에 있어서,상기 방법은,Merge 후보 리스트, AMVP 후보 리스트 및/또는 기설정값을 기반으로 적어도 하나의 후보 BV를 얻는 단계를 더 포함하는 방법.</claim></claimInfo><claimInfo><claim>27. 제26항에 있어서,상기 Merge 후보 리스트 또는 AMVP 후보 리스트 중 상위 N개의 후보 BV를 획득하는 방법.</claim></claimInfo><claimInfo><claim>28. 제26항에 있어서,상기 기설정값은 0인 방법.</claim></claimInfo><claimInfo><claim>29. 제1항 내지 제28항 중 어느 한 항에 있어서,상기 하나 또는 복수의 예측 템플릿은 제1 오프셋 항을 더 포함하며, 상기 제1 오프셋 항은 상기 현재 블록의 템플릿의 샘플 값 비트 심도를 기반으로 생성된 템플릿을 가리키며;상기 하나 또는 복수의 제1 예측 블록은 제2 오프셋 항을 더 포함하며, 상기 제2 오프셋 항은 상기 현재 블록의 샘플 값 비트 심도를 기반으로 생성된 블록을 가리키는 방법.</claim></claimInfo><claimInfo><claim>30. 제1항 내지 제29항 중 어느 한 항에 있어서,상기 하나 또는 복수의 예측 템플릿은 제3 오프셋 항을 더 포함하며, 상기 제3 오프셋 항은 특정 예측 모드 또는 특정 MV를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하여 얻은 예측 템플릿을 가리키며;상기 하나 또는 복수의 제1 예측 블록은 제4 오프셋 항을 더 포함하며, 상기 제4 오프셋 항은 상기 특정 예측 모드 또는 상기 특정 MV를 기반으로 상기 현재 블록에 대해 예측을 수행하여 얻은 예측 블록을 가리키는 방법.</claim></claimInfo><claimInfo><claim>31. 제30항에 있어서,상기 특정 예측 모드는 Planar 모드 및/또는 DC 모드를 포함하는 방법.</claim></claimInfo><claimInfo><claim>32. 제30항에 있어서,상기 방법은,상기 특정 예측 모드와 상기 예측 파라미터가 지시하는 인트라 예측 모드가 동일하지 않은 것으로 확인된 경우, 상기 특정 예측 모드를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하는 단계를 더 포함하는 방법.</claim></claimInfo><claimInfo><claim>33. 제30항에 있어서,상기 방법은,상기 특정 MV와 상기 예측 파라미터가 지시하는 상기 현재 블록의 MV가 동일하지 않은 것으로 확인된 경우, 상기 특정 MV를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하는 단계를 더 포함하는 방법.</claim></claimInfo><claimInfo><claim>34. 제10항 내지 제28항 중 어느 한 항에 있어서,상기 하나 또는 복수의 예측 템플릿은 제1 비선형 항을 더 포함하며, 상기 제1 비선형 항은 상기 샘플 값 오차가 가장 작은 후보 예측 템플릿에 대해 변환을 수행하여 얻은 예측 템플릿을 가리키며;상기 하나 또는 복수의 제1 예측 블록은 제2 비선형 항을 더 포함하며, 상기 제2 비선형 항은 상기 샘플 값 오차가 가장 작은 후보 예측 템플릿에 대응하는 제1 예측 블록에 대해 상기 변환을 수행하여 얻은 예측 블록을 가리키는 방법.</claim></claimInfo><claimInfo><claim>35. 제29항, 제30항 또는 제34항에 있어서,상기 하나 또는 복수의 예측 템플릿이 N개 미만인 경우, 상기 제1 오프셋 항, 상기 제3 오프셋 항, 상기 제1 비선형 항 및 제1 기설정값 중 적어도 하나를 추가함으로써 예측 템플릿을 N개로 보충하는 방법; 이에 상응하여, 상기 제2 오프셋 항, 상기 제4 오프셋 항, 상기 제2 비선형 항 및 제2 기설정값 중 적어도 하나를 추가함으로써 제1 예측 블록을 N개로 보충하는 방법.</claim></claimInfo><claimInfo><claim>36. 제35항에 있어서,상기 제1 기설정값은 0인 방법.</claim></claimInfo><claimInfo><claim>37. 제10항 내지 제29항 중 어느 한 항에 있어서,상기 변환은 제곱 계산을 포함하는 방법.</claim></claimInfo><claimInfo><claim>38. 제1항 내지 제37항 중 어느 한 항에 있어서,상기 하나 또는 복수의 예측 템플릿은, Chroma Fusion, OBMC, MHP 및/또는 SGPM 방법에서 그 융합 작업 이전의 중간 예측 모드를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하여 얻은 예측 템플릿을 더 포함하는 방법.</claim></claimInfo><claimInfo><claim>39. 제1항 내지 제38항 중 어느 한 항에 있어서,상기의, 상기 현재 블록의 템플릿과 상기 하나 또는 복수의 예측 템플릿을 기반으로 상기 하나 또는 복수의 예측 템플릿의 가중치를 결정하는 단계는,상기 현재 블록의 템플릿과 상기 하나 또는 복수의 예측 템플릿을 기반으로 상기 하나 또는 복수의 예측 템플릿의 가중치를 결정하여, 상기 현재 블록의 템플릿과 상기 현재 블록의 템플릿의 목표 예측 값 사이의 샘플 값 오차를 최소화하는 단계를 포함하되, 상기 목표 예측 값은 상기 하나 또는 복수의 예측 템플릿의 샘플 값의 가중 합과 같은 방법.</claim></claimInfo><claimInfo><claim>40. 제39항에 있어서,상기의, 상기 현재 블록의 템플릿과 상기 하나 또는 복수의 예측 템플릿을 기반으로 상기 하나 또는 복수의 예측 템플릿의 가중치를 결정하는 단계는,상기 예측 템플릿의 샘플 값을 기반으로 상기 예측 템플릿의 자기 상관 행렬을 결정하는 단계;상기 예측 템플릿의 샘플 값과 상기 현재 블록의 템플릿의 샘플 값을 기반으로 상기 예측 템플릿과 상기 현재 블록의 템플릿의 상호 상관 벡터를 결정하는 단계; 및상기 자기 상관 행렬과 상기 상호 상관 벡터를 기반으로 상기 하나 또는 복수의 예측 템플릿의 가중치를 결정하는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>41. 제39항 또는 제40항에 있어서,상기 샘플 값 오차의 유형은 MSE, SATD, SAD, MAD, MAE, NCC, SSE 중 하나인 방법.</claim></claimInfo><claimInfo><claim>42. 제1항에 있어서,상기 방법은,상기 현재 블록의 제2 예측 블록을 기반으로 상기 현재 블록의 잔차 블록을 결정하는 단계; 및상기 잔차 블록을 기반으로 비트스트림을 생성하는 단계를 더 포함하는 방법.</claim></claimInfo><claimInfo><claim>43. 디코더에 적용되는 디코딩 방법으로서,현재 블록의 템플릿과 상기 현재 블록의 템플릿의 하나 또는 복수의 예측 템플릿을 결정하는 단계;상기 현재 블록의 템플릿과 상기 하나 또는 복수의 예측 템플릿을 기반으로 상기 하나 또는 복수의 예측 템플릿의 가중치를 결정하는 단계;상기 현재 블록의 예측 파라미터를 기반으로 상기 현재 블록의 하나 또는 복수의 제1 예측 블록을 결정하는 단계;상기 하나 또는 복수의 예측 템플릿의 가중치를 기반으로 상기 하나 또는 복수의 제1 예측 블록에 대해 융합을 수행하여, 상기 현재 블록의 제2 예측 블록을 얻는 단계; 및상기 제2 예측 블록을 기반으로 상기 현재 블록의 재구성 값을 결정하는 단계를 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>44. 제43항에 있어서,상기의, 상기 제2 예측 블록을 기반으로 상기 현재 블록의 재구성 값을 결정하는 단계는,비트스트림을 디코딩하여 상기 현재 블록에 대응하는 잔차 블록을 결정하는 단계; 및상기 잔차 블록과 상기 제2 예측 블록을 기반으로 상기 현재 블록의 재구성 값을 결정하는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>45. 제43항에 있어서,상기 예측 파라미터가 지시하는 인트라 예측 모드를 기반으로 상기 현재 블록의 제1 예측 블록을 결정하는 방법.</claim></claimInfo><claimInfo><claim>46. 제43항에 있어서,상기 예측 파라미터가 지시하는 상기 현재 블록의 모션 파라미터를 기반으로 상기 현재 블록의 제1 예측 블록을 결정하는 방법.</claim></claimInfo><claimInfo><claim>47. 제46항에 있어서,상기 모션 파라미터는 모션 벡터 및 참조 이미지 인덱스 중 적어도 하나의 파라미터를 포함하는 방법.</claim></claimInfo><claimInfo><claim>48. 제43항 내지 제47항 중 어느 한 항에 있어서,상기 현재 블록의 예측 파라미터와 상기 현재 블록의 템플릿의 예측 파라미터는 동일한 방법.</claim></claimInfo><claimInfo><claim>49. 제43항에 있어서,상기 현재 블록의 템플릿의 예측 템플릿을 결정하는 것은,상기 현재 블록의 템플릿의 샘플에 대해 HoG 계산을 수행하여 해당 샘플의 그래디언트 방향과 그래디언트 크기를 얻는 단계;상기 그래디언트 방향과 그래디언트 크기를 기반으로 각도 모드를 결정하는 단계; 및상기 각도 모드를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하여 상기 예측 템플릿을 얻는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>50. 제49항에 있어서,상기의, 상기 그래디언트 방향과 그래디언트 크기를 기반으로 각도 모드를 결정하는 단계는,상기 그래디언트 방향을 미리 정의된 후보 각도 모드로 전환하는 단계; 및상기 그래디언트 크기를 기반으로, 전환된 후보 각도 모드에서 상기 각도 모드를 결정하는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>51. 제50항에 있어서,상기의, 상기 그래디언트 크기를 기반으로 각도 모드를 결정하는 단계는,N개의 가장 큰 그래디언트 크기에 대응하는 후보 각도 모드를 기반으로 N개의 상기 각도 모드를 얻는 단계; 제1 임계값보다 크거나 같은 그래디언트 크기에 대응하는 후보 각도 모드를 기반으로 하나 또는 복수의 상기 각도 모드를 얻는 단계; 및 적어도 하나의 제1 그래디언트 크기와의 차이값이 제2 임계값보다 작거나 같은 제2 그래디언트 크기에 대응하는 후보 각도 모드를 기반으로 하나 또는 복수의 상기 각도 모드를 얻는 단계 중 적어도 하나를 포함하는 방법.</claim></claimInfo><claimInfo><claim>52. 제51항에 있어서,상기 적어도 하나의 제1 그래디언트 크기의 값은 상기 제2 그래디언트 크기와 인접한 방법.</claim></claimInfo><claimInfo><claim>53. 제43항에 있어서,상기 현재 블록의 템플릿의 예측 템플릿을 결정하는 것은,모드 리스트 중의 후보 예측 모드를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하여 후보 예측 템플릿을 얻는 단계; 및상기 후보 예측 템플릿과 상기 현재 블록의 템플릿 사이의 샘플 값 오차를 기반으로 상기 예측 템플릿을 얻는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>54. 제53항에 있어서,상기의, 상기 후보 예측 템플릿과 상기 현재 블록의 템플릿 사이의 샘플 값 오차를 기반으로 상기 예측 템플릿을 얻는 단계는,N개의 가장 작은 샘플 값 오차에 대응하는 후보 예측 템플릿을 기반으로 N개의 상기 예측 템플릿을 얻는 단계; 또는,제3 임계값보다 작거나 같은 샘플 값 오차에 대응하는 후보 예측 템플릿을 기반으로 하나 또는 복수의 상기 예측 템플릿을 얻는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>55. 제53항 또는 제54항에 있어서,상기 샘플 값 오차의 유형은 적어도 SATD, SAD, MAD, MAE, NCC, MSE, SSE 중 하나인 방법.</claim></claimInfo><claimInfo><claim>56. 제47항에 있어서,상기 모드 리스트 중의 후보 예측 모드는,제49항 내지 제52항 중 어느 한 항에 따른 단계를 통해 얻은 상기 각도 모드;MPM 리스트 중의 예측 모드;Planar 모드가 삭제된 MPM 리스트 중의 예측 모드;상기 MPM 리스트 중 각도가 제4 임계값보다 크거나 같은 각도 모드에 대해 확장을 수행하여 얻은 각도 모드; 및상기 MPM 리스트 중 각도 모드가 제5 임계값보다 작거나 같은 각도 모드에 대해 확장을 수행하여 얻은 각도 모드 중 적어도 하나를 포함하는 방법.</claim></claimInfo><claimInfo><claim>57. 제56항에 있어서,상기 MPM 리스트에서, DC 모드는 상기 현재 블록의 인접 블록을 기반으로 구성된 각도 모드 이후 또는 이전에 위치하는 방법.</claim></claimInfo><claimInfo><claim>58. 제56항에 있어서,상기 모드 리스트에서, 상기 N개의 각도 모드는 상기 현재 블록의 인접 블록을 가반으로 구성된 각도 모드 이후 또는 이전에 위치하는 방법.</claim></claimInfo><claimInfo><claim>59. 제53항 내지 제58항 중 어느 한 항에 있어서,상기의, 모드 리스트 중의 후보 예측 모드를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하여 후보 예측 템플릿을 얻는 단계는,상기 현재 블록의 템플릿의 참조 영역의 샘플 값과 상기 후보 예측 모드를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하여 후보 예측 템플릿을 얻는 단계를 포함하되, 상기 참조 영역은 상기 현재 블록의 템플릿의 비인접 영역 및/또는 인접 영역을 포함하는 방법.</claim></claimInfo><claimInfo><claim>60. 제59항에 있어서,상기 참조 영역은 상기 현재 블록의 템플릿의 좌상측 영역, 상측 영역, 우상측 영역, 좌측 영역 및/또는 좌하측 영역을 포함하는 방법.</claim></claimInfo><claimInfo><claim>61. 제53항 내지 제58항 중 어느 한 항에 있어서,상기의, 모드 리스트 중의 후보 예측 모드를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하여 후보 예측 템플릿을 얻는 단계는,상기 모드 리스트 중의 후보 예측 모드와 상기 현재 블록의 템플릿의 참조 라인 리스트 중의 참조 라인을 조합하여 조합 리스트를 얻는 단계; 및조합 리스트 중 조합이 지시하는 후보 예측 모드와 참조 라인을 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하여 후보 예측 템플릿을 얻는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>62. 제61항에 있어서,상기 참조 라인 리스트에 포함된 참조 라인 인덱스는 {1,3,5,7,12} 또는 {1,4,5,7,10,12} 또는 {1,2,3,7,10,11}인 방법.</claim></claimInfo><claimInfo><claim>63. 제43항 내지 제62항 중 어느 한 항에 있어서,상기 현재 블록의 템플릿의 예측 템플릿을 결정하는 것은,적어도 하나의 후보 MV를 결정하는 단계; 및상기 후보 MV와 상기 현재 블록의 참조 이미지를 기반으로 상기 현재 블록의 템플릿에 대해 모션 보상을 수행하여 상기 예측 템플릿을 얻는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>64. 제63항에 있어서,상기 현재 블록의 참조 이미지는 상기 현재 블록의 순방향 참조 이미지 또는 역방향 참조 이미지인 방법.</claim></claimInfo><claimInfo><claim>65. 제63항에 있어서,상기의, 적어도 하나의 후보 MV를 결정하는 단계는,Merge 후보 리스트 또는 AMVP 후보 리스트를 기반으로 적어도 하나의 후보 MV를 얻는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>66. 제65항에 있어서,상기의, Merge 후보 리스트 또는 AMVP 후보 리스트를 기반으로 적어도 하나의 후보 MV를 얻는 단계는,상기 Merge 후보 리스트 또는 AMVP 후보 리스트 중 상위 N개의 후보 MV를 획득하는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>67. 제66항에 있어서,상기 Merge 후보 리스트 또는 AMVP 후보 리스트 중의 후보 MV는 템플릿 매칭, DMVR 및/또는 Multipass DMVR을 통해 리파인된 MV이며; 및/또는, 상기 Merge 후보 리스트 또는 AMVP 후보 리스트 중의 후보 MV는 원본 후보 리스트에서 약속된 순서에 따라 정렬된 후보 MV인 방법.</claim></claimInfo><claimInfo><claim>68. 제43항 내지 제67항 중 어느 한 항에 있어서,상기 현재 블록의 템플릿의 예측 템플릿을 결정하는 것은,적어도 하나의 후보 BV를 결정하는 단계; 및상기 후보 BV, 상기 현재 블록 및 현재 이미지를 기반으로 상기 현재 블록의 템플릿의 예측 템플릿을 결정하는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>69. 제68항에 있어서,상기 방법은,Merge 후보 리스트, AMVP 후보 리스트 및/또는 기설정값을 기반으로 적어도 하나의 후보 BV를 얻는 단계를 더 포함하는 방법.</claim></claimInfo><claimInfo><claim>70. 제68항에 있어서,상기 Merge 후보 리스트 또는 AMVP 후보 리스트 중 상위 N개의 후보 BV를 획득하는 방법.</claim></claimInfo><claimInfo><claim>71. 제69항에 있어서,상기 기설정값은 0인 방법.</claim></claimInfo><claimInfo><claim>72. 제43항 내지 제67항 중 어느 한 항에 있어서,상기 하나 또는 복수의 예측 템플릿은 제1 오프셋 항을 더 포함하며, 상기 제1 오프셋 항은 상기 현재 블록의 템플릿의 샘플 값 비트 심도를 기반으로 생성된 템플릿을 가리키며;상기 하나 또는 복수의 제1 예측 블록은 제2 오프셋 항을 더 포함하며, 상기 제2 오프셋 항은 상기 현재 블록의 샘플 값 비트 심도를 기반으로 생성된 블록을 가리키는 방법.</claim></claimInfo><claimInfo><claim>73. 제43항 내지 제67항 중 어느 한 항에 있어서,상기 하나 또는 복수의 예측 템플릿은 제3 오프셋 항을 더 포함하며, 상기 제3 오프셋 항은 특정 예측 모드 또는 특정 MV를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하여 얻은 예측 템플릿을 가리키며;상기 하나 또는 복수의 제1 예측 블록은 제4 오프셋 항을 더 포함하며, 상기 제4 오프셋 항은 상기 특정 예측 모드 또는 상기 특정 MV를 기반으로 상기 현재 블록에 대해 예측을 수행하여 얻은 예측 블록을 가리키는 방법.</claim></claimInfo><claimInfo><claim>74. 제73항에 있어서,상기 특정 예측 모드는 Planar 모드 및/또는 DC 모드를 포함하는 방법.</claim></claimInfo><claimInfo><claim>75. 제73항에 있어서,상기 방법은,상기 특정 예측 모드와 상기 예측 파라미터가 지시하는 인트라 예측 모드가 동일하지 않은 것으로 확인된 경우, 상기 특정 예측 모드를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하는 단계를 더 포함하는 방법.</claim></claimInfo><claimInfo><claim>76. 제73항에 있어서,상기 방법은,상기 특정 MV와 상기 예측 파라미터가 지시하는 상기 현재 블록의 MV가 동일하지 않은 것으로 확인된 경우, 상기 특정 MV를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하는 단계를 더 포함하는 방법.</claim></claimInfo><claimInfo><claim>77. 제53항 내지 제71항 중 어느 한 항에 있어서,상기 하나 또는 복수의 예측 템플릿은 제1 비선형 항을 더 포함하며, 상기 제1 비선형 항은 상기 샘플 값 오차가 가장 작은 후보 예측 템플릿에 대해 변환을 수행하여 얻은 예측 템플릿을 가리키며;상기 하나 또는 복수의 제1 예측 블록은 제2 비선형 항을 더 포함하며, 상기 제2 비선형 항은 상기 샘플 값 오차가 가장 작은 후보 예측 템플릿에 대응하는 제1 예측 블록에 대해 상기 변환을 수행하여 얻은 예측 블록을 가리키는 방법.</claim></claimInfo><claimInfo><claim>78. 제72항, 제73항 또는 제77항에 있어서,상기 하나 또는 복수의 예측 템플릿이 N개 미만인 경우, 상기 제1 오프셋 항, 상기 제3 오프셋 항, 상기 제1 비선형 항 및 제1 기설정값 중 적어도 하나를 추가함으로써 예측 템플릿을 N개로 보충하는 방법; 이에 상응하여, 상기 제2 오프셋 항, 상기 제4 오프셋 항, 상기 제2 비선형 항 및 제2 기설정값 중 적어도 하나를 추가함으로써 제1 예측 블록을 N개로 보충하는 방법.</claim></claimInfo><claimInfo><claim>79. 제78항에 있어서,상기 제1 기설정값은 0인 방법.</claim></claimInfo><claimInfo><claim>80. 제77항 중 어느 한 항에 있어서,상기 변환은 제곱 계산을 포함하는 방법.</claim></claimInfo><claimInfo><claim>81. 제49항 내지 제80항 중 어느 한 항에 있어서,상기 하나 또는 복수의 예측 템플릿은, Chroma Fusion, OBMC, MHP 및/또는 SGPM 방법에서 그 융합 작업 이전의 중간 예측 모드를 기반으로 상기 현재 블록의 템플릿에 대해 예측을 수행하여 얻은 예측 템플릿을 더 포함하는 방법.</claim></claimInfo><claimInfo><claim>82. 제43항 내지 제81항 중 어느 한 항에 있어서,상기의, 상기 현재 블록의 템플릿과 상기 하나 또는 복수의 예측 템플릿을 기반으로 상기 하나 또는 복수의 예측 템플릿의 가중치를 결정하는 단계는,상기 현재 블록의 템플릿과 상기 하나 또는 복수의 예측 템플릿을 기반으로 상기 하나 또는 복수의 예측 템플릿의 가중치를 결정하여, 상기 현재 블록의 템플릿과 상기 현재 블록의 템플릿의 목표 예측 값 사이의 샘플 값 오차를 최소화하는 단계를 포함하되, 상기 목표 예측 값은 상기 하나 또는 복수의 예측 템플릿의 샘플 값의 가중 합과 같은 방법.</claim></claimInfo><claimInfo><claim>83. 제82항에 있어서,상기의, 상기 현재 블록의 템플릿과 상기 하나 또는 복수의 예측 템플릿을 기반으로 상기 하나 또는 복수의 예측 템플릿의 가중치를 결정하는 단계는,상기 예측 템플릿의 샘플 값을 기반으로 상기 예측 템플릿의 자기 상관 행렬을 결정하는 단계;상기 예측 템플릿의 샘플 값과 상기 현재 블록의 템플릿의 샘플 값을 기반으로 상기 예측 템플릿과 상기 현재 블록의 템플릿의 상호 상관 벡터를 결정하는 단계; 및상기 자기 상관 행렬과 상기 상호 상관 벡터를 기반으로 상기 하나 또는 복수의 예측 템플릿의 가중치를 결정하는 단계를 포함하는 방법.</claim></claimInfo><claimInfo><claim>84. 제82항 또는 제83항에 있어서,상기 샘플 값 오차의 유형은 MSE, SATD, SAD, MAD, MAE, NCC, SSE 중 하나인 방법.</claim></claimInfo><claimInfo><claim>85. 인코더에 적용되는 인코딩 장치로서,현재 블록의 템플릿과 상기 현재 블록의 템플릿의 하나 또는 복수의 예측 템플릿을 결정하도록 구성된 제1 결정 모듈;상기 현재 블록의 템플릿과 상기 하나 또는 복수의 예측 템플릿을 기반으로 상기 하나 또는 복수의 예측 템플릿의 가중치를 결정하도록 구성된 제2 결정 모듈;상기 현재 블록의 예측 파라미터를 기반으로 상기 현재 블록의 하나 또는 복수의 제1 예측 블록을 결정하도록 구성된 제3 결정 모듈; 및상기 하나 또는 복수의 예측 템플릿의 가중치를 기반으로 상기 하나 또는 복수의 제1 예측 블록에 대해 융합을 수행하여 상기 현재 블록의 제2 예측 블록을 얻도록 구성된 제1 융합 모듈을 포함하는 인코딩 장치.</claim></claimInfo><claimInfo><claim>86. 제1 메모리 및 제1 프로세서를 포함하는 인코더로서,상기 제1 메모리는, 상기 제1 프로세서에서 실행 가능한 컴퓨터 프로그램을 저장하도록 구성되며;상기 제1 프로세서는, 상기 컴퓨터 프로그램을 실행할 때, 제1항 내지 제42항 중 어느 한 항에 따른 방법을 수행하도록 구성된 인코더.</claim></claimInfo><claimInfo><claim>87. 디코더에 적용되는 디코딩 장치로서,현재 블록의 템플릿과 상기 현재 블록의 템플릿의 하나 또는 복수의 예측 템플릿을 결정하도록 구성된 제4 결정 모듈;상기 현재 블록의 템플릿과 상기 하나 또는 복수의 예측 템플릿을 기반으로 상기 하나 또는 복수의 예측 템플릿의 가중치를 결정하도록 구성된 제5 결정 모듈;상기 현재 블록의 예측 파라미터를 기반으로 상기 현재 블록의 하나 또는 복수의 제1 예측 블록을 결정하도록 구성된 제6 결정 모듈;상기 하나 또는 복수의 예측 템플릿의 가중치를 기반으로 상기 하나 또는 복수의 제1 예측 블록에 대해 융합을 수행하여 상기 현재 블록의 제2 예측 블록을 얻도록 구성된 제2 융합 모듈; 및상기 제2 예측 블록을 기반으로 상기 현재 블록의 재구성 값을 결정하도록 구성된 제7 결정 모듈을 포함하는 디코딩 장치.</claim></claimInfo><claimInfo><claim>88. 제2 메모리 및 제2 프로세서를 포함하는 디코더로서,상기 제2 메모리는, 상기 제2 프로세서에서 실행 가능한 컴퓨터 프로그램을 저장하도록 구성되며;상기 제2 프로세서는, 상기 컴퓨터 프로그램을 실행할 때, 제43항 내지 제84항 중 어느 한 항에 따른 방법을 수행하도록 구성된 디코더.</claim></claimInfo><claimInfo><claim>89. 비트스트림으로서,상기 비트스트림은 현재 블록의 제2 예측 블록을 기반으로 결정된 잔차 블록에 따라 생성된 것이며,상기 제2 예측 블록은 제1항 내지 제41항 중 어느 한 항에 따른 방법을 통해 얻은 것인 비트스트림.</claim></claimInfo><claimInfo><claim>90. 전자 기기로서,프로세서 및 컴퓨터 판독 가능 저장매체를 포함하되,상기 프로세서는 컴퓨터 프로그램을 실행하는 것에 적합하며,상기 컴퓨터 판독 가능 저장매체에는 컴퓨터 프로그램이 저장되어 있으며, 상기 컴퓨터 프로그램이 상기 프로세서에 의해 실행될 때 제1항 내지 제42항 중 어느 한 항에 따른 방법을 구현하거나, 또는 상기 컴퓨터 프로그램이 상기 프로세서에 의해 실행될 때 제43항 내지 제84항 중 어느 한 항에 따른 방법을 구현하는 전자 기기.</claim></claimInfo><claimInfo><claim>91. 컴퓨터 판독 가능 저장매체로서,상기 컴퓨터 판독 가능 저장매체에는 컴퓨터 프로그램이 저장되어 있으며, 상기 컴퓨터 프로그램이 실행될 때 제1항 내지 제43항 중 어느 한 항에 따른 방법을 구현하거나, 또는 상기 컴퓨터 프로그램이 실행될 때 제43항 내지 제84항 중 어느 한 항에 따른 방법을 구현하는 컴퓨터 판독 가능 저장매체.</claim></claimInfo></claimInfoArray><applicantInfoArray><applicantInfo><address>중국, 광동 ******, 동관, 창안, 우샤, 하이빈 로드, 넘버 **</address><code>520160675505</code><country>중국</country><engName>GUANGDONG OPPO MOBILE TELECOMMUNICATIONS CORP., LTD.</engName><name>광동 오포 모바일 텔레커뮤니케이션즈 코포레이션 리미티드</name></applicantInfo></applicantInfoArray><inventorInfoArray><inventorInfo><address>중국,...</address><code> </code><country>중국</country><engName>MA, Yanzhuo</engName><name>마, 옌줘</name></inventorInfo><inventorInfo><address>중국,...</address><code> </code><country>중국</country><engName>HUO, Junyan</engName><name>훠, 쥔옌</name></inventorInfo><inventorInfo><address>중국,...</address><code> </code><country>중국</country><engName>YANG, Fuzheng</engName><name>양, 푸정</name></inventorInfo><inventorInfo><address>중국,...</address><code> </code><country>중국</country><engName>DU, Hongqing</engName><name>두, 홍칭</name></inventorInfo><inventorInfo><address>중국,...</address><code> </code><country>중국</country><engName>LI, Ming</engName><name>리, 밍</name></inventorInfo></inventorInfoArray><agentInfoArray><agentInfo><address>서울 강남구 언주로 **길 **, 대림아크로텔 *층(도곡동)</address><code>920031000651</code><country>대한민국</country><engName>C&amp;amp;S Patent and Law Office</engName><name>특허법인씨엔에스(유)</name></agentInfo></agentInfoArray><priorityInfoArray/><designatedStateInfoArray/><priorArtDocumentsInfoArray/><legalStatusInfoArray><legalStatusInfo><commonCodeName>수리 (Accepted) </commonCodeName><documentEngName>[Patent Application] Document according to the Article 203 of Patent Act</documentEngName><documentName>[특허출원]특허법 제203조에 따른 서면</documentName><receiptDate>2025.08.19</receiptDate><receiptNumber>1-1-2025-0946534-57</receiptNumber></legalStatusInfo><legalStatusInfo><commonCodeName>발송처리완료 (Completion of Transmission) </commonCodeName><documentEngName>Notice of Acceptance</documentEngName><documentName>수리안내서</documentName><receiptDate>2025.08.25</receiptDate><receiptNumber>1-5-2025-0142890-43</receiptNumber></legalStatusInfo></legalStatusInfoArray><imagePathInfo><docName>1020257027646.jpg</docName><largePath>http://plus.kipris.or.kr/kiprisplusws/fileToss.jsp?arg=6c650beb4cee9ce4122b704b88878c93c36a90f6218edad0e57166f4d993e77de399def9a40ebf58ca786b42f848e5f7be60cd08f0d081d75974a8f163d8d90986c0e3e13d42346d</largePath><path>http://plus.kipris.or.kr/kiprisplusws/fileToss.jsp?arg=ed43a0609e94d6e22d01c5c32ba711cfa86d01f579aa2bab1dc23ec9673d3cd21780f41296088f030e4bfa85ee01876648c55b64e8dc9b8eb2c189c42350a991c9a16ac2fa98210b</path></imagePathInfo><rndInfoArray/></item></body><count><numOfRows>1</numOfRows><pageNo>1</pageNo><totalCount>1</totalCount></count></response>