<?xml version="1.0" encoding="UTF-8" standalone="yes"?><response><header><requestMsgID></requestMsgID><responseTime>2025-11-17 17:54:49.5449</responseTime><responseMsgID></responseMsgID><successYN>Y</successYN><resultCode>00</resultCode><resultMsg>NORMAL SERVICE.</resultMsg></header><body><item><biblioSummaryInfoArray><biblioSummaryInfo><applicationDate>2023.01.04</applicationDate><applicationFlag> </applicationFlag><applicationNumber>10-2025-7025697</applicationNumber><claimCount>91</claimCount><examinerName> </examinerName><finalDisposal> </finalDisposal><inventionTitle>인코딩 및 디코딩 방법, 비트스트림, 인코더, 디코더 및 저장 매체</inventionTitle><inventionTitleEng>CODING METHOD, DECODING METHOD, CODE STREAM, CODER, DECODER, AND STORAGE MEDIUM</inventionTitleEng><openDate>2025.08.25</openDate><openNumber>10-2025-0126848</openNumber><originalApplicationDate> </originalApplicationDate><originalApplicationKind>국제출원/신규</originalApplicationKind><originalApplicationNumber> </originalApplicationNumber><originalExaminationRequestDate> </originalExaminationRequestDate><originalExaminationRequestFlag>N</originalExaminationRequestFlag><publicationDate> </publicationDate><publicationNumber> </publicationNumber><registerDate> </registerDate><registerNumber> </registerNumber><registerStatus>공개</registerStatus><translationSubmitDate>2025.07.31</translationSubmitDate></biblioSummaryInfo></biblioSummaryInfoArray><ipcInfoArray><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/105</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/117</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/137</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/176</ipcNumber></ipcInfo><ipcInfo><ipcDate>(2014.01.01)</ipcDate><ipcNumber>H04N 19/70</ipcNumber></ipcInfo></ipcInfoArray><familyInfoArray><familyInfo/></familyInfoArray><abstractInfoArray><abstractInfo><astrtCont> 본 출원의 실시예에서는 인코딩 및 디코딩 방법, 비트스트림, 인코더, 디코더 및 저장 매체를 공개하며, 상기 방법은，현재 블록의 제1 템플릿을 결정하고, 매칭 템플릿과 참조 블록을 결정하며; 제1 템플릿과 매칭 템플릿에 근거하여 모델 파라미터를 결정하며; 모델 파라미터에 근거하여 참조 블록에 대해 필터링 처리를 수행하고, 필터링된 참조 블록을 결정하며; 필터링된 참조 블록에 근거하여 현재 블록의 예측 값을 결정하며; 현재 블록의 예측 값에 근거하여 현재 블록의 재구성 값을 결정하는 것을 포함한다. 이로써, 예측 정확성을 높이고, 비트레이트를 절감하는 동시에 인코딩 및 디코딩 성능을 향상시킬 수 있다. </astrtCont></abstractInfo></abstractInfoArray><internationalInfoArray><internationalInfo><internationOpenDate>2024.07.11</internationOpenDate><internationOpenNumber>WO2024145850</internationOpenNumber><internationalApplicationDate>2023.01.04</internationalApplicationDate><internationalApplicationNumber>PCT/CN2023/070559</internationalApplicationNumber></internationalInfo></internationalInfoArray><claimInfoArray><claimInfo><claim>1. 디코더에 적용되는 디코딩 방법으로서, 상기 방법은현재 블록의 제1 템플릿을 결정하고, 매칭 템플릿과 참조 블록을 결정하며;상기 제1 템플릿과 상기 매칭 템플릿에 근거하여 모델 파라미터를 결정하며;상기 모델 파라미터에 근거하여 상기 참조 블록에 대해 필터링 처리를 수행하고, 필터링된 참조 블록을 결정하며;상기 필터링된 참조 블록에 근거하여 상기 현재 블록의 예측 값을 결정하며;상기 현재 블록의 예측 값에 근거하여 상기 현재 블록의 재구성 값을 결정하는 것을 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>2. 제1항에 있어서, 상기 현재 블록의 제1 템플릿을 결정하는 것은,상기 현재 블록의 템플릿 유형을 결정하고;상기 현재 블록의 템플릿 유형에 근거하여 상기 현재 블록의 제1 템플릿을 결정하는 것을 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>3. 제2항에 있어서,상기 현재 블록의 템플릿 유형을 결정하는 것은,상기 현재 블록의 참조 픽셀에 근거하여 상기 현재 블록의 템플릿 유형을 결정하는 것을 포함하며,여기서, 상기 현재 블록의 참조 픽셀은 상기 현재 블록의 좌측 인접 참조 픽셀, 상기 현재 블록의 상측 인접 참조 픽셀, 상기 현재 블록의 좌측 상부 인접 참조 픽셀, 상기 현재 블록의 좌측 하부 인접 참조 픽셀, 상기 현재 블록의 우측 상부 인접 참조 픽셀중의 적어도 하나를 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>4. 제3항에 있어서,상기 현재 블록의 템플릿 유형을 결정하는 것은,상기 현재 블록의 좌측 인접 참조 픽셀, 상기 현재 블록의 상측 인접 참조 픽셀 및 상기 현재 블록의 좌측 상부 인접 참조 픽셀이 모두 사용 가능한 경우, 상기 현재 블록의 템플릿 유형을 제1 값으로 결정하고;상기 현재 블록의 좌측 인접 참조 픽셀이 사용 가능한 경우, 상기 현재 블록의 템플릿 유형을 제2 값으로 결정하며;상기 현재 블록의 상측 인접 참조 픽셀이 사용 가능한 경우, 상기 현재 블록의 템플릿 유형을 제3 값으로 결정하며;상기 현재 블록의 좌측 인접 참조 픽셀과 상기 현재 블록의 좌측 상부 인접 참조 픽셀이 모두 사용 가능한 경우, 상기 현재 블록의 템플릿 유형을 제4 값으로 결정하며;상기 현재 블록의 좌측 인접 참조 픽셀과 상기 현재 블록의 좌측 하부 인접 참조 픽셀이 모두 사용 가능한 경우, 상기 현재 블록의 템플릿 유형을 제5 값으로 결정하며;상기 현재 블록의 상측 인접 참조 픽셀과 상기 현재 블록의 우측 상부 인접 참조 픽셀이 모두 사용 가능할 경우, 상기 현재 블록의 템플릿 유형을 제6 값으로 결정하는 것을 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>5. 제1항에 있어서,상기 매칭 템플릿과 참조 블록을 결정하는 것은,상기 제1 템플릿에 근거하여 사전 설정 검색 영역에서 템플릿 매칭을 수행하여, 상기 매칭 템플릿을 결정하고;상기 매칭 템플릿에 근거하여 상기 참조 블록을 결정하는 것을 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>6. 제5항에 있어서,상기 제1 템플릿에 근거하여 사전 설정 검색 영역에서 템플릿 매칭을 수행하여, 상기 매칭 템플릿을 결정하는 것은,상기 제1 템플릿에 따라 상기 사전 설정 검색 영역에서 검색을 수행하여 목표 블록 벡터를 결정하고, 상기 목표 블록 벡터에 근거하여 상기 매칭 템플릿을 결정하는 것을 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>7. 제1항에 있어서,상기 매칭 템플릿과 참조 블록을 결정하는 것은,비트스트림을 디코딩하여 운동 파라미터를 결정하고;상기 운동 파라미터에 근거하여 상기 참조 블록을 결정하며;상기 제1 템플릿과 상기 참조 블록에 근거하여 상기 매칭 템플릿을 결정하는 것을 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>8. 제6항에 있어서,상기 제1 템플릿에 따라 상기 사전 설정 검색 영역에서 검색을 수행하여 목표 블록 벡터를 결정하는 것은,상기 사전 설정 검색 영역에서 제1 검색을 수행하여 상기 목표 블록 벡터를 결정하 고; 또는상기 사전 설정 검색 영역에서 제2 검색을 수행하여 상기 목표 블록 벡터를 결정하는 것을 포함하며,여기서, 상기 제1 검색에 대응하는 검색 간격은 상기 제2 검색에 대응하는 검색 간격보다 큰 디코딩 방법.</claim></claimInfo><claimInfo><claim>9. 제6항에 있어서,상기 제1 템플릿에 따라 상기 사전 설정 검색 영역에서 검색을 수행하여 목표 블록 벡터를 결정하는 것은,상기 사전 설정 검색 영역에서 제1 검색을 수행하여, 제1 블록 벡터를 결정하고 상기 제1 블록 벡터에 근거하여 초기 매칭 템플릿을 결정하며;상기 초기 매칭 템플릿에 근거하여 제1 검색 영역을 결정하고, 상기 제1 검색 영역 내에서 제2 검색을 수행하여 상기 목표 블록 벡터를 결정하는 것을 포함하며,여기서, 상기 제1 검색에 대응하는 검색 간격은 상기 제2 검색에 대응하는 검색 간격보다 크고, 상기 제1 검색 영역은 상기 사전 설정 검색 영역보다 작은 디코딩 방법.</claim></claimInfo><claimInfo><claim>10. 제6항에 있어서,상기 사전 설정 검색 영역은 적어도 하나의 하위 검색 영역을 포함하고,상기 제1 템플릿에 따라 상기 사전 설정 검색 영역에서 검색을 수행하여, 목표 블록 벡터를 결정하는 것은,상기 적어도 하나의 하위 검색 영역에서 각각 검색하여, 각 하위 검색 영역의 최적 블록 벡터 및 대응하는 매칭 비용 값을 결정하며;상기 각 하위 검색 영역의 최적 블록 벡터 및 대응하는 매칭 비용 값에 근거하여, 최소 매칭 비용 값에 대응하는 최적 블록 벡터를 결정하며;상기 최소 매칭 비용 값에 대응하는 최적 블록 벡터를 상기 목표 블록 벡터로 사용하는 것을 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>11. 제10항에 있어서,상기 제1 템플릿에 따라 상기 사전 설정 검색 영역에서 검색을 수행하여, 목표 블록 벡터를 결정하는 것은,상기 적어도 하나의 하위 검색 영역에서 각각 제1 검색을 수행하여, 각 하위 검색 영역의 최적 블록 벡터 및 대응하는 제2 검색 영역을 결정하고;각 하위 검색 영역의 최적 블록 벡터 및 대응하는 제2 검색 영역에 근거하여 영역을 판단하고, 제2 검색에 참여하는 적어도 2개의 목표 하위 검색 영역을 결정하며;상기 적어도 2개의 목표 하위 검색 영역에서 제2 검색을 수행하여, 상기 적어도 2개의 목표 하위 검색 영역에 대응하는 최적 블록 벡터를 결정하며;상기 적어도 2개의 목표 하위 검색 영역에 대응하는 최적 블록 벡터를 상기 목표 블록 벡터로 사용하는 것을 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>12. 제1항에 있어서,상기 제1 템플릿과 상기 매칭 템플릿에 근거하여 모델 파라미터를 결정하는 것은상기 모델 파라미터는 목표 필터 계수를 포함하는 것을 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>13. 제12항에 있어서,상기 방법은,상기 제1 템플릿의 픽셀 참조 값과 상기 매칭 템플릿의 픽셀 참조 값에 근거하여, 상기 목표 필터 계수를 결정하는 것을 더 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>14. 제13항에 있어서,상기 방법은상기 목표 필터 계수는 상기 매칭 템플릿의 픽셀 참조 값이 상기 목표 필터에 의해 처리된 후의 출력 값과 상기 제1 템플릿의 픽셀 참조 값 사이의 제1 오차가 제1 조건을 충족할 때 상기 목표 필터에서 사용하는 계수인 것을 더 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>15. 제14항에 있어서,상기 방법은상기 제1 조건은 상기 제1 오차가 최소인 것을 더 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>16. 제14항에 있어서,상기 방법은상기 제1 조건은 상기 제1 오차가 제1 사전 설정 임계값 범위 내에 있는 것을 더 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>17. 제14항에 있어서,상기 방법은상기 제1 조건은 상기 제1 오차의 변화량이 제2 사전 설정 임계값 범위 내에 있는 것을 더 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>18. 제13항에 있어서,상기 제1 템플릿의 픽셀 참조 값과 상기 매칭 템플릿의 픽셀 참조 값에 근거하여, 상기 목표 필터 계수를 결정하는 것은상기 매칭 템플릿의 픽셀 참조 값에 근거하여 자기상관 매개변수를 결정하고;상기 제1 템플릿의 픽셀 참조 값과 상기 매칭 템플릿의 픽셀 참조 값에 근거하여 상호상관 매개변수를 결정하며;상기 자기상관 매개변수와 상기 상호상관 매개변수에 근거하여, 상기 목표 필터 계수를 결정하는 것을 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>19. 제13항에 있어서,상기 픽셀 참조 값은 픽셀 재구성 값, 픽셀 기울기 값 및 픽셀 위치 정보 중 적어도 하나를 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>20. 제12항에 있어서,상기 목표 필터 계수의 개수는 제1 사전 설정 값과 동일한 디코딩 방법.</claim></claimInfo><claimInfo><claim>21. 제12항에 있어서,상기 방법은,비트스트림을 디코딩하여 상기 목표 필터 계수의 개수를 결정하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>22. 제12항에 있어서,상기 목표 필터는 사전 설정된 형상의 1차원 또는 2차원 필터인 디코딩 방법.</claim></claimInfo><claimInfo><claim>23. 제12항에 있어서,상기 방법은,비트스트림을 디코딩하여 상기 목표 필터의 형상을 결정하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>24. 제12항에 있어서,상기 모델 파라미터에 근거하여 상기 참조 블록에 대해 필터링 처리를 수행하여, 필터링된 참조 블록을 결정하는 것은상기 모델 파라미터에 근거하여 상기 참조 블록에 대해 필터링 처리를 수행하여 상기 목표 필터의 제1 출력 값을 결정하고;상기 목표 필터의 제1 출력 값에 따라 상기 필터링된 참조 블록을 결정하는 것을 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>25. 제24항에 있어서,상기 모델 파라미터에 근거하여 상기 참조 블록에 대해 필터링 처리를 수행하여 상기 목표 필터의 제1 출력 값을 결정하는 것은상기 참조 블록의 픽셀 재구성 값 및 대응하는 상기 목표 필터의 계수의 곱을 계산하고;상기 목표 필터의 제1 출력 값을 n개의 상기 곱의 합과 같도록 설정하는 것을 포함하며,여기서, n은 상기 목표 필터 계수의 개수를 나타내고, n은 양의 정수인디코딩 방법.</claim></claimInfo><claimInfo><claim>26. 제24항에 있어서,상기 모델 파라미터에 근거하여 상기 참조 블록에 대해 필터링 처리를 수행하여 상기 목표 필터의 제1 출력 값을 결정하는 것은상기 참조 블록의 픽셀 재구성 값의 상기 제1 매핑 관계에서의 제1 값을 결정하고;상기 제1 값 및 대응하는 상기 목표 필터의 계수의 곱을 계산하며;상기 목표 필터의 제1 출력 값을  n개의 상기 곱의 합과 같도록 설정하는 것을 포함하고,여기서, n은 상기 목표 필터 계수의 개수를 나타내고, n은 양의 정수인디코딩 방법.</claim></claimInfo><claimInfo><claim>27. 제24항에 있어서,상기 목표 필터의 제1 출력 값에 따라 상기 필터링된 참조 블록을 결정하는 것은제1 오프셋 값을 결정하고;상기 제1 출력 값과 상기 제1 오프셋 값에 근거하여 덧셈 연산을 진행하여, 상기 필터링된 참조 블록을 결정하는 것을 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>28. 제27항에 있어서,상기 제1 오프셋 값을 결정하는 것은상기 제1 오프셋 값을 제2 사전 설정 값과 동일하게 설정하는 것을 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>29. 제27항에 있어서,상기 제1 오프셋 값을 결정하는 것은상기 목표 필터 계수의 개수가 n인 경우, 상기 목표 필터의 제n+1 계수를 결정하고;상기 제n+1 계수와 제2 오프셋 값에 근거하여 상기 제1 오프셋 값을 결정하는 것을 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>30. 제29항에 있어서,상기 방법은상기 제2 오프셋 값을 제3 사전 설정 값과 동일하게 설정하고; 또는상기 제2 오프셋 값을 상기 참조 블록의 픽셀 재구성 값의 제2 매핑 관계에서의 값과 동일하게 설정하는 것을 더 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>31. 제1항에 있어서,상기 필터링된 참조 블록에 근거하여 상기 현재 블록의 예측 값을 결정하는 것은 상기 필터링된 참조 블록에 대해 제1 처리를 수행하여 상기 현재 블록의 예측 값을 얻는 것을 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>32. 제31항에 있어서,상기 방법은상기 제1 처리는 상기 현재 블록의 예측 값을 상기 필터링된 참조 블록과 동일하게 설정하는 것을 더 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>33. 제31항에 있어서,상기 방법은상기 제1 처리는 상기 필터링된 참조 블록을 사전 설정된 수치 범위로 제한하는 클리핑 작업인 것을 더 포함하는디코딩 방법.</claim></claimInfo><claimInfo><claim>34. 제1항에 있어서,상기 방법은상기 제1 템플릿과 상기 매칭 템플릿에 근거하여 복수의 모델 파라미터 세트를 결정하며;상기 복수의 모델 파라미터 세트에 근거하여 복수의 필터 모델을 구축하고, 상기 복수의 필터 모델에 근거하여 각각 상기 참조 블록에 대해 필터링 처리를 수행하여, 복수의 필터링된 참조 블록을 결정하며;상기 복수의 필터링된 참조 블록에 근거하여 상기 현재 블록의 예측 값을 결정하는 것을 더 포함하는디코딩 방법.</claim></claimInfo><claimInfo><claim>35. 제34항에 있어서,상기 복수의 필터링된 참조 블록에 근거하여 상기 현재 블록의 예측 값을 결정하는 것은상기 복수의 필터링된 참조 블록에 대해 가중 계산을 수행하여 상기 현재 블록의 예측 값을 결정하는 것을 포함하는 디코딩 방법.</claim></claimInfo><claimInfo><claim>36. 제34항에 있어서,상기 방법은비트스트림을 디코딩하여 목표 모델 인덱스 값을 결정하고;상기 목표 모델 인덱스 값에 근거하여 상기 복수의 필터 모델에서 대응하는 목표 필터를 결정하며;상기 목표 필터에 근거하여 상기 참조 블록에 대해 필터링 처리를 수행하여, 상기 현재 블록의 예측 값을 결정하는 것을 더 포함하는디코딩 방법.</claim></claimInfo><claimInfo><claim>37. 제34항에 있어서,상기 제1 템플릿과 상기 매칭 템플릿에 근거하여 복수의 모델 파라미터 세트를 결정는 것은상기 제1 템플릿과 상기 매칭 템플릿 내의 재구성 픽셀을 각각 사전 설정된 방식에 따라 분류하여 복수의 하위 템플릿 세트와 복수의 하위 매칭 템플릿 세트를 얻으며;상기 복수의 하위 템플릿 세트와 상기 복수의 하위 매칭 템플릿 세트에 근거하여 상기 복수의 모델 파라미터 세트를 결정하는 것을 포함하는디코딩 방법.</claim></claimInfo><claimInfo><claim>38. 제1항에 있어서,상기 방법은비트스트림을 디코딩하여 제1 신택스 엘리먼트 식별 정보의 값을 결정하고;상기 제1 신택스 엘리먼트 식별 정보가 상기 현재 블록에 인트라 템플릿 매칭이 적용된 것을 나타내는 경우, 비트스 트림을 디코딩하여 제2 신택스 엘리먼트 식별 정보의 값을 결정하며;상기 제2 신택스 엘리먼트 식별 정보가 상기 현재 블록에 필터 모델이 적용된 것을 나타내는 경우, 상기 모델 파라미터에 근거하여 상기 참조 블록에 대해 필터링 처리를 수행하여 필터링된 참조 블록을 결정하며; 및상기 필터링된 참조 블록에 근거하여 상기 현재 블록의 예측 값을 결정하는 것을 더 포함하는디코딩 방법.</claim></claimInfo><claimInfo><claim>39. 제38항에 있어서,상기 방법은상기 제2 신택스 엘리먼트 식별 정보가 상기 현재 블록에 필터 모델이 적용되지 않는 것을 나타내는 경우, 상기 참조 블록의 재구성 픽셀 값을 상기 현재 블록의 예측 값으로 사용하는 것을 더 포함하는디코딩 방법.</claim></claimInfo><claimInfo><claim>40. 제1내제 39중의 어느 한항에 있어서,상기 현재 블록의 예측 값에 근거하여 상기 현재 블록의 재구성 값을 결정하는 것은비트스트림을 디코딩하여 상기 현재 블록의 예측잔여 값을 결정하고;상기 현재 블록의 예측 값과 상기 현재 블록의 예측잔여 값에 근거하여 상기 현재 블록의 재구성 값을 결정하는 것을 포함하는디코딩 방법.</claim></claimInfo><claimInfo><claim>41. 인코더에 적용되는 인코딩 방법으로서, 상기 방법은현재 블록의 제1 템플릿을 결정하고, 매칭 템플릿과 참조 블록을 결정하며;상기 제1 템플릿과 상기 매칭 템플릿에 근거하여 모델 파라미터를 결정하며;상기 모델 파라미터에 근거하여 상기 참조 블록에 대해 필터링 처리를 수행하고, 필터링된 참조 블록을 결정하며;상기 필터링된 참조 블록에 근거하여 상기 현재 블록의 예측 값을 결정하며;상기 현재 블록의 예측 값에 근거하여 상기 현재 블록의 예측잔여 값을 결정하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>42. 제41항에 있어서, 상기 현재 블록의 제1 템플릿을 결정하는 것은,상기 현재 블록의 템플릿 유형을 결정하고;상기 현재 블록의 템플릿 유형에 근거하여 상기 현재 블록의 제1 템플릿을 결정하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>43. 제42항에 있어서, 상기 현재 블록의 템플릿 유형을 결정하는 것은,상기 현재 블록의 참조 픽셀에 근거하여 상기 현재 블록의 템플릿 유형을 결정하는 것을 포함하며,여기서, 상기 현재 블록의 참조 픽셀은 상기 현재 블록의 좌측 인접 참조 픽셀, 상기 현재 블록의 상측 인접 참조 픽셀, 상기 현재 블록의 좌측 상부 인접 참조 픽셀, 상기 현재 블록의 좌측 하부 인접 참조 픽셀, 상기 현재 블록의 우측 상부 인접 참조 픽셀중의 적어도 하나를 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>44. 제43항에 있어서, 상기 현재 블록의 템플릿 유형을 결정하는 것은,상기 현재 블록의 좌측 인접 참조 픽셀, 상기 현재 블록의 상측 인접 참조 픽셀 및 상기 현재 블록의 좌측 상부 인접 참조 픽셀이 모두 사용 가능한 경우, 상기 현재 블록의 템플릿 유형을 제1 값으로 결정하고;상기 현재 블록의 좌측 인접 참조 픽셀이 사용 가능한 경우, 상기 현재 블록의 템플릿 유형을 제2 값으로 결정하며;상기 현재 블록의 상측 인접 참조 픽셀이 사용 가능한 경우, 상기 현재 블록의 템플릿 유형을 제3 값으로 결정하며;상기 현재 블록의 좌측 인접 참조 픽셀과 상기 현재 블록의 좌측 상부 인접 참조 픽셀이 모두 사용 가능한 경우, 상기 현재 블록의 템플릿 유형을 제4 값으로 결정하며;상기 현재 블록의 좌측 인접 참조 픽셀과 상기 현재 블록의 좌측 하부 인접 참조 픽셀이 모두 사용 가능한 경우, 상기 현재 블록의 템플릿 유형을 제5 값으로 결정하며;상기 현재 블록의 상측 인접 참조 픽셀과 상기 현재 블록의 우측 상부 인접 참조 픽셀이 모두 사용 가능할 경우, 상기 현재 블록의 템플릿 유형을 제6 값으로 결정하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>45. 제41항에 있어서,상기 매칭 템플릿과 참조 블록을 결정하는 것은,상기 제1 템플릿에 근거하여 사전 설정 검색 영역에서 템플릿 매칭을 수행하여, 상기 매칭 템플릿을 결정하고;상기 매칭 템플릿에 근거하여 상기 참조 블록을 결정하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>46. 제45항에 있어서,상기 제1 템플릿에 근거하여 사전 설정 검색 영역에서 템플릿 매칭을 수행하여, 상기 매칭 템플릿을 결정하는 것은,상기 제1 템플릿에 따라 상기 사전 설정 검색 영역에서 검색을 수행하여 목표 블록 벡터를 결정하고, 상기 목표 블록 벡터에 근거하여 상기 매칭 템플릿을 결정하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>47. 제41항에 있어서,상기 매칭 템플릿과 참조 블록을 결정하는 것은,운동 파라미터 및 대응하는 참조 블록을 결정하고;상기 제1 템플릿과 상기 참조 블록에 근거하여 상기 매칭 템플릿을 결정하는 것을 포함하고,상응하게, 상기 방법은상기 운동 파라미터에 대해 인코딩하여, 획득된 인코딩 비트를 비트스트림에 기록하는 것을 더 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>48. 제46항에 있어서,상기 제1 템플릿에 따라 상기 사전 설정 검색 영역에서 검색을 수행하여 목표 블록 벡터를 결정하는 것은,상기 사전 설정 검색 영역에서 제1 검색을 수행하여 상기 목표 블록 벡터를 결정하고; 또는상기 사전 설정 검색 영역에서 제2 검색을 수행하여 상기 목표 블록 벡터를 결정하는 것을 포함하며,여기서, 상기 제1 검색에 대응하는 검색 간격은 상기 제2 검색에 대응하는 검색 간격보다 큰 인코딩 방법.</claim></claimInfo><claimInfo><claim>49. 제46항에 있어서,상기 제1 템플릿에 따라 상기 사전 설정 검색 영역에서 검색을 수행하여 목표 블록 벡터를 결정하는 것은,상기 사전 설정 검색 영역에서 제1 검색을 수행하여, 제1 블록 벡터를 결정하고 상기 제1 블록 벡터에 근거하여 초기 매칭 템플릿을 결정하며;상기 초기 매칭 템플릿에 근거하여 제1 검색 영역을 결정하고, 상기 제1 검색 영역 내에서 제2 검색을 수행하여 상기 목표 블록 벡터를 결정하는 것을 포함하며,여기서, 상기 제1 검색에 대응하는 검색 간격은 상기 제2 검색에 대응하는 검색 간격보다 크고, 상기 제1 검색 영역은 상기 사전 설정 검색 영역보다 작은 인코딩 방법.</claim></claimInfo><claimInfo><claim>50. 제46항에 있어서,상기 사전 설정 검색 영역은 적어도 하나의 하위 검색 영역을 포함하고,상기 제1 템플릿에 따라 상기 사전 설정 검색 영역에서 검색을 수행하여, 목표 블록 벡터를 결정하는 것은,상기 적어도 하나의 하위 검색 영역에서 각각 검색하여, 각 하위 검색 영역의 최적 블록 벡터 및 대응하는 매칭 비용 값을 결정하며;상기 각 하위 검색 영역의 최적 블록 벡터 및 대응하는 매칭 비용 값에 근거하여, 최소 매칭 비용 값에 대응하는 최적 블록 벡터를 결정하며;상기 최소 매칭 비용 값에 대응하는 최적 블록 벡터를 상기 목표 블록 벡터로 사용하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>51. 제50항에 있어서,상기 제1 템플릿에 따라 상기 사전 설정 검색 영역에서 검색을 수행하여, 목표 블록 벡터를 결정하는 것은,상기 적어도 하나의 하위 검색 영역에서 각각 제1 검색을 수행하여, 각 하위 검색 영역의 최적 블록 벡터 및 대응하는 제2 검색 영역을 결정하고;각 하위 검색 영역의 최적 블록 벡터 및 대응하는 제2 검색 영역에 근거하여 영역을 판단하고, 제2 검색에 참여하는 적어도 2개의 목표 하위 검색 영역을 결정하며;상기 적어도 2개의 목표 하위 검색 영역에서 제2 검색을 수행하여, 상기 적어도 2개의 목표 하위 검색 영역에 대응하는 최적 블록 벡터를 결정하며;상기 적어도 2개의 목표 하위 검색 영역에 대응하는 최적 블록 벡터를 상기 목표 블록 벡터로 사용하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>52. 제41항에 있어서,상기 제1 템플릿과 상기 매칭 템플릿에 근거하여 모델 파라미터를 결정하는 것은상기 모델 파라미터는 목표 필터 계수를 포함하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>53. 제52항에 있어서,상기 방법은,상기 제1 템플릿의 픽셀 참조 값과 상기 매칭 템플릿의 픽셀 참조 값에 근거하여, 상기 목표 필터 계수를 결정하는 것을 더 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>54. 제53항에 있어서,상기 방법은상기 목표 필터 계수는 상기 매칭 템플릿의 픽셀 참조 값이 상기 목표 필터에 의해 처리된 후의 출력 값과 상기 제1 템플릿의 픽셀 참조 값 사이의 제1 오차가 제1 조건을 충족할 때 상기 목표 필터에서 사용하는 계수인 것을 더 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>55. 제54항에 있어서,상기 방법은상기 제1 조건은 상기 제1 오차가 최소인 것을 더 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>56. 제54항에 있어서,상기 방법은상기 제1 조건은 상기 제1 오차가 제1 사전 설정 임계값 범위 내에 있는 것을 더 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>57. 제54항에 있어서,상기 방법은상기 제1 조건은 상기 제1 오차의 변화량이 제2 사전 설정 임계값 범위 내에 있는 것을 더 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>58. 제53항에 있어서,상기 제1 템플릿의 픽셀 참조 값과 상기 매칭 템플릿의 픽셀 참조 값에 근거하여, 상기 목표 필터 계수를 결정하는 것은상기 매칭 템플릿의 픽셀 참조 값에 근거하여 자기상관 매개변수를 결정하고;상기 제1 템플릿의 픽셀 참조 값과 상기 매칭 템플릿의 픽셀 참조 값에 근거하여 상호상관 매개변수를 결정하며;상기 자기상관 매개변수와 상기 상호상관 매개변수에 근거하여, 상기 목표 필터 계수를 결정하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>59. 제53항에 있어서,상기 픽셀 참조 값은 픽셀 재구성 값, 픽셀 기울기 값 및 픽셀 위치 정보 중 적어도 하나를 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>60. 제52항에 있어서,상기 목표 필터 계수의 개수는 제1 사전 설정 값과 동일한 인코딩 방법.</claim></claimInfo><claimInfo><claim>61. 제52항에 있어서,상기 방법은,상기 목표 필터 계수의 개수를 결정하고;상기 목표 필터 계수의 개수에 대해 인코딩하여, 획득된 인코딩 비트를 비트스트림에 기록하는 것을 더 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>62. 제52항에 있어서,상기 목표 필터는 사전 설정된 형상의 1차원 또는 2차원 필터인 인코딩 방법.</claim></claimInfo><claimInfo><claim>63. 제52항에 있어서,상기 방법은,상기 목표 필터의 형상을 결정하고;상기 목표 필터의 형상에 대해 인코딩하여, 획득된 인코딩 비트를 비트스트림에 기록하는 것을 더 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>64. 제52항에 있어서,상기 모델 파라미터에 근거하여 상기 참조 블록에 대해 필터링 처리를 수행하여, 필터링된 참조 블록을 결정하는 것은상기 모델 파라미터에 근거하여 상기 참조 블록에 대해 필터링 처리를 수행하여 상기 목표 필터의 제1 출력 값을 결정하고;상기 목표 필터의 제1 출력 값에 따라 상기 필터링된 참조 블록을 결정하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>65. 제64항에 있어서,상기 모델 파라미터에 근거하여 상기 참조 블록에 대해 필터링 처리를 수행하여 상기 목표 필터의 제1 출력 값을 결정하는 것은상기 참조 블록의 픽셀 재구성 값 및 대응하는 상기 목표 필터의 계수의 곱을 계산하고;상기 목표 필터의 제1 출력 값을 n개의 상기 곱의 합과 같도록 설정하는 것을 포함하며,여기서, n은 상기 목표 필터 계수의 개수를 나타내고, n은 양의 정수인코딩 방법.</claim></claimInfo><claimInfo><claim>66. 제64항에 있어서,상기 모델 파라미터에 근거하여 상기 참조 블록에 대해 필터링 처리를 수행하여 상기 목표 필터의 제1 출력 값을 결정하는 것은상기 참조 블록의 픽셀 재구성 값의 상기 제1 매핑 관계에서의 제1 값을 결정하고;상기 제1 값 및 대응하는 상기 목표 필터의 계수의 곱을 계산하며;상기 목표 필터의 제1 출력 값을 n개의 상기 곱의 합과 같도록 설정하는 것을 포함하고,여기서, n은 상기 목표 필터 계수의 개수를 나타내고, n은 양의 정수인코딩 방법.</claim></claimInfo><claimInfo><claim>67. 제64항에 있어서,상기 목표 필터의 제1 출력 값에 따라 상기 필터링된 참조 블록을 결정하는 것은제1 오프셋 값을 결정하고;상기 제1 출력 값과 상기 제1 오프셋 값에 근거하여 덧셈 연산을 진행하여, 상기 필터링된 참조 블록을 결정하는 것을 포함하는 코딩 방법.</claim></claimInfo><claimInfo><claim>68. 제67항에 있어서,상기 제1 오프셋 값을 결정하는 것은상기 제1 오프셋 값을 제2 사전 설정 값과 동일하게 설정하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>69. 제67항에 있어서,상기 제1 오프셋 값을 결정하는 것은상기 목표 필터 계수의 개수가 n인 경우, 상기 목표 필터의 제n+1 계수를 결정하고;상기 제n+1 계수와 제2 오프셋 값에 근거하여 상기 제1 오프셋 값을 결정하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>70. 제69항에 있어서,상기 방법은상기 제2 오프셋 값을 제3 사전 설정 값과 동일하게 설정하고; 또는상기 제2 오프셋 값을 상기 참조 블록의 픽셀 재구성 값의 제2 매핑 관계에서의 값과 동일하게 설정하는 것을 더 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>71. 제41항에 있어서,상기 필터링된 참조 블록에 근거하여 상기 현재 블록의 예측 값을 결정하는 것은상기 필터링된 참조 블록에 대해 제1 처리를 수행하여 상기 현재 블록의 예측 값을 얻는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>72. 제71항에 있어서,상기 방법은상기 제1 처리는 상기 현재 블록의 예측 값을 상기 필터링된 참조 블록과 동일하게 설정하는 것을 더 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>73. 제71항에 있어서,상기 방법은상기 제1 처리는 상기 필터링된 참조 블록을 사전 설정된 수치 범위로 제한하는 클리핑 작업인 것을 더 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>74. 제41항에 있어서,상기 방법은상기 제1 템플릿과 상기 매칭 템플릿에 근거하여 복수의 모델 파라미터 세트를 결정하며;상기 복수의 모델 파라미터 세트에 근거하여 복수의 필터 모델을 구축하고, 상기 복수의 필터 모델에 근거하여 각각 상기 참조 블록에 대해 필터링 처리를 수행하여, 복수의 필터링된 참조 블록을 결정하며;상기 복수의 필터링된 참조 블록에 근거하여 상기 현재 블록의 예측 값을 결정하는 것을 더 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>75. 제74항에 있어서,상기 복수의 필터링된 참조 블록에 근거하여 상기 현재 블록의 예측 값을 결정하는 것은상기 복수의 필터링된 참조 블록에 대해 가중 계산을 수행하여 상기 현재 블록의 예측 값을 결정하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>76. 제74항에 있어서,상기 방법은복수의 필터 모델에서 목표 필터를 결정하며;상기 목표 필터에 근거하여 상기 참조 블록에 대해 필터링 처리를 수행하여, 상기 현재 블록의 예측 값을 결정하는 것을 더 포함하는  인코딩 방법.</claim></claimInfo><claimInfo><claim>77. 제76항에 있어서,상기 방법은목표 모델 인덱스 값을 결정하고, 여기서 상기 목표 모델 인덱스 값은 상기 복수의 필터 모델에서 상기 목표 필터의 인덱스 번호를 나타내고;상기 목표 모델 인덱스 값에 대해 인코딩하고, 얻은 인코딩 비트를 비트스트림에 기록하는 것을 더 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>78. 제76항에 있어서,상기 복수의 필터 모델에서 목표 필터를 결정하는 것은상기 현재 블록의 원본 값을 결정하고;상기 현재 블록의 원본 값과 상기 현재 블록의 복수의 초기 예측 값에 근거하여 각각 비율 왜곡 비용 계산을 수행하여, 상기 복수의 초기 예측 값 각각의 비율 왜곡 비용 값을 결정하며;상기 복수의 초기 예측 값 각각의 비율 왜곡 비용 값에서 최소 비율 왜곡 비용 값을 결정하며;상기 최소 비율 왜곡 비용 값에 대응하는 필터 모델을 상기 목표 필터로 사용하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>79. 제74항에 있어서,상기 제1 템플릿과 상기 매칭 템플릿에 근거하여 복수의 모델 파라미터 세트를 결정는 것은상기 제1 템플릿과 상기 매칭 템플릿내의 재구성 픽셀을 각각 사전 설정된 방식에 따라 분류하여 복수의 하위 템플릿 세트와 복수의 하위 매칭 템플릿 세트를 얻으며;상기 복수의 하위 템플릿 세트와 상기 복수의 하위 매칭 템플릿 세트에 근거하여 상기 복수의 모델 파라미터 세트를 결정하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>80. 제41항에 있어서,상기 방법은제1 신택스 엘리먼트 식별 정보의 값을 결정하되, 상기 제1 신택스 엘리먼트 식별 정보는 상기 현재 블록에 인트라 템플릿 매칭 적용 여부를 나타내며;상기 제1 신택스 엘리먼트 식별 정보의 값에 대해 인코딩하고, 얻은 인코딩 비트를 비트스트림에 기록하는 것을 더 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>81. 제80항에 있어서,상기 제1 신택스 엘리먼트 식별 정보의 값을 결정하는 것은상기 현재 블록에 인트라 템플릿 매칭이 적용되는 경우, 상기 제1 신택스 엘리먼트 식별 정보의 값을 제1값으로 결정하고;상기 현재 블록에 인트라 템플릿 매칭이 적용되지 않은 경우, 상기 제1 신택스 엘리먼트 식별 정보의 값을 제2값으로 결정하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>82. 제80항에 있어서,상기 제1 신택스 엘리먼트 식별 정보가 상기 현재 블록에 인트라 템플릿 매칭이 적용된 것을 나타내는 경우, 상기 방법은제2 신택스 엘리먼트 식별 정보의 값을 결정하되, 상기 제2 신택스 엘리먼트 식별 정보는 상기 현재 블록에 필터 모델 적용 여부를 나타내며;상기 제2 신택스 엘리먼트 식별 정보의 값에 대해 인코딩하고, 얻은 인코딩 비트를 비트스트림에 기록하는 것을 더 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>83. 제82항에 있어서,상기 제2 신택스 엘리먼트 식별 정보의 값을 결정하는 것은상기 현재 블록에 필터 모델이 적용되는 경우, 상기 제2 신택스 엘리먼트 식별 정보의 값을 제1값으로 결정하고;상기 현재 블록에 필터 모델이 적용되지 않은 경우, 상기 제2 신택스 엘리먼트 식별 정보의 값을 제2값으로 결정하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>84. 제82항에 있어서,상기 방법은상기 현재 블록에 필터 모델을 적용하는 경우, 상기 모델 파라미터에 근거하여 상기 참조 블록에 대해 필터링 처리를 수행하여 필터링된 참조 블록을 결정하고;상기 필터링된 참조 블록에 근거하여 상기 현재 블록의 예측 값을 결정하며;상기 현재 블록에 필터 모델이 적용되지 않은 경우, 상기 참조 블록의 재구성 픽셀 값을 상기 현재 블록의 예측 값으로 사용하는 것을 더 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>85. 제41내제 84중의 어느 한항에 있어서,상기 현재 블록의 예측 값에 근거하여 상기 현재 블록의 예측잔여 값을 결정하는 것은상기 현재 블록의 원본 값을 결정하고;상기 현재 블록의 원본 값과 상기 현재 블록의 예측 값에 근거하여 상기 현재 블록의 예측잔여 값을 결정하는 것을 포함하는 인코딩 방법.</claim></claimInfo><claimInfo><claim>86. 인코딩 대기 정보에 근거하여 비트 인코딩하여 생성된 비트스트림에 있어서, 상기 인코딩 대기 정보는 현재 블록의 예측잔여 값, 목표 필터 계수의 개수, 목표 필터의 형상, 제1 신택스 엘리먼트 식별 정보의 값, 제2 신택스 엘리먼트 식별 정보의 값 중의 적어도 하나를 포함하며, 여기서 제1 신택스 엘리먼트 식별 정보는 상기 현재 블록에 인트라 템플릿 매칭 적용 여부를 나타내고, 상기 제2 신택스 엘리먼트 식별 정보는 상기 현재 블록에 필터 모델 적용 여부를 나타내는 비트스트림.</claim></claimInfo><claimInfo><claim>87. 인코더에 있어서,제1 결정 유닛, 제1 필터 유닛 및 제1 예측 유닛을 포함하고,상기 제1 결정 유닛은 현재 블록의 제1 템플릿을 결정하고, 매칭 템플릿과 참조 블록을 결정하며, 또한 상기 제1 템플릿과 상기 매칭 템플릿에 근거하여 모델 파라미터를 결정하도록 구성되고,상기 제1 필터 유닛은 상기 모델 파라미터에 근거하여 상기 참조 블록에 대해 필터링 처리를 수행하여 필터링된 참조 블록을 결정하도록 구성되며,상기 제1 예측 유닛은 상기 필터링된 참조 블록에 근거하여 상기 현재 블록의 예측 값을 결정하도록 구성되고, 및상기 제1 결정 유닛은 또한 상기 현재 블록의 예측 값에 근거하여 상기 현재 블록의 예측 잔여 값을 결정하도록 구성되는 인코더.</claim></claimInfo><claimInfo><claim>88. 인코더에 있어서,제1 프로세서에서 실행될 수 있는 컴퓨터 프로그램을 저장하는 제1 메모리; 및컴퓨터 프로그램을 실행할 때 청구항 41 내지85 중 어느 한 항에 따른 방법을 실행하도록 구성된 제1 프로세서를 포함하는 인코더.</claim></claimInfo><claimInfo><claim>89. 디코더에 있어서,제2 결정 유닛, 제2 필터 유닛 및 제2 예측 유닛을 포함하고,상기 제2 결정 유닛은 현재 블록의 제1 템플릿을 결정하고, 매칭 템플릿과 참조 블록을 결정하며, 또한 상기 제1 템플릿과 상기 매칭 템플릿에 근거하여 모델 파라미터를 결정하도록 구성되고,상기 제2 필터 유닛은 상기 모델 파라미터에 근거하여 상기 참조 블록에 대해 필터링 처리를 수행하여 필터링된 참조 블록을 결정하도록 구성되며,상기 제2 예측 유닛은 상기 필터링된 참조 블록에 근거하여 상기 현재 블록의 예측 값을 결정하도록 구성되고, 및상기 제2 결정 유닛은 또한 상기 현재 블록의 예측 값에 근거하여 상기 현재 블록의 재구성 값을 결정하도록 구성되는 디코더.</claim></claimInfo><claimInfo><claim>90. 디코더에 있어서,제2 프로세서에서 실행될 수 있는 컴퓨터 프로그램을 저장하는 제2 메모리; 및컴퓨터 프로그램을 실행할 때 청구항 1 내지40 중 어느 한 항에 따른 방법을 실행하도록 구성된 제2 프로세서를 포함하는 디코더.</claim></claimInfo><claimInfo><claim>91. 컴퓨터 판독 가능 저장 매체에 있어서컴퓨터 프로그램을 저장하고, 상기 컴퓨터 프로그램을 실행할 경우 청구항 1 내지 40 중 어느 한 항에 따른 방법, 또는 청구항 41 내지 85 중 어느 한 항에 따른 방법을 실현하는 컴퓨터 판독 가능 저장 매체.</claim></claimInfo></claimInfoArray><applicantInfoArray><applicantInfo><address>중국, 광동 ******, 동관, 창안, 우샤, 하이빈 로드, 넘버 **</address><code>520160675505</code><country>중국</country><engName>GUANGDONG OPPO MOBILE TELECOMMUNICATIONS CORP., LTD.</engName><name>광동 오포 모바일 텔레커뮤니케이션즈 코포레이션 리미티드</name></applicantInfo></applicantInfoArray><inventorInfoArray><inventorInfo><address>중국,...</address><code> </code><country>중국</country><engName>HUO, Junyan</engName><name>훠, 쥔옌</name></inventorInfo><inventorInfo><address>중국,...</address><code> </code><country>중국</country><engName>MA, Yanzhuo</engName><name>마, 옌줘</name></inventorInfo><inventorInfo><address>중국,...</address><code> </code><country>중국</country><engName>YANG, Fuzheng</engName><name>양, 푸정</name></inventorInfo><inventorInfo><address>중국,...</address><code> </code><country>중국</country><engName>QIAO, Wenhan</engName><name>치아오, 원한</name></inventorInfo><inventorInfo><address>중국,...</address><code> </code><country>중국</country><engName>LI, Ming</engName><name>리, 밍</name></inventorInfo></inventorInfoArray><agentInfoArray><agentInfo><address>서울 강남구 언주로 **길 **, 대림아크로텔 *층(도곡동)</address><code>920031000651</code><country>대한민국</country><engName>C&amp;amp;S Patent and Law Office</engName><name>특허법인씨엔에스(유)</name></agentInfo></agentInfoArray><priorityInfoArray/><designatedStateInfoArray/><priorArtDocumentsInfoArray/><legalStatusInfoArray><legalStatusInfo><commonCodeName>수리 (Accepted) </commonCodeName><documentEngName>[Patent Application] Document according to the Article 203 of Patent Act</documentEngName><documentName>[특허출원]특허법 제203조에 따른 서면</documentName><receiptDate>2025.07.31</receiptDate><receiptNumber>1-1-2025-0870165-08</receiptNumber></legalStatusInfo><legalStatusInfo><commonCodeName>발송처리완료 (Completion of Transmission) </commonCodeName><documentEngName>Notice of Acceptance</documentEngName><documentName>수리안내서</documentName><receiptDate>2025.08.05</receiptDate><receiptNumber>1-5-2025-0131713-23</receiptNumber></legalStatusInfo><legalStatusInfo><commonCodeName>보정승인간주 (Regarded as an acceptance of amendment) </commonCodeName><documentEngName>[Amendment to Description, etc.] Amendment</documentEngName><documentName>[명세서등 보정]보정서</documentName><receiptDate>2025.08.07</receiptDate><receiptNumber>1-1-2025-0898929-17</receiptNumber></legalStatusInfo></legalStatusInfoArray><imagePathInfo><docName>1020257025697.jpg</docName><largePath>http://plus.kipris.or.kr/kiprisplusws/fileToss.jsp?arg=6c650beb4cee9ce4122b704b88878c9387d67d972056d2993100cf30f5e328b9e4f483070582e8976634986060112f3433e8e29db0b4a89410603e6b904450cf58fd01f334c4e19f</largePath><path>http://plus.kipris.or.kr/kiprisplusws/fileToss.jsp?arg=ed43a0609e94d6e22d01c5c32ba711cf1e2d9a0c5393ced2710799128ccdba976bfcfc2253028d383a3151c340ba8ee794cbdddb8756f25d3097752892487564b05316c0b0eb50bc</path></imagePathInfo><rndInfoArray/></item></body><count><numOfRows>1</numOfRows><pageNo>1</pageNo><totalCount>1</totalCount></count></response>